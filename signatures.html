<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Questions about your function signatures - cppfaq.rs</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="code.html"><strong aria-hidden="true">2.</strong> Questions about code in function bodies</a></li><li class="chapter-item expanded "><a href="signatures.html" class="active"><strong aria-hidden="true">3.</strong> Questions about your function signatures</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">4.</strong> Questions about your types</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Questions about your APIs</div></li><li class="chapter-item expanded "><a href="codebase.html"><strong aria-hidden="true">6.</strong> Questions about your whole codebase</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Questions about your processes</div></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">cppfaq.rs</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/google/rust-design-faq" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="questions-about-your-function-signatures"><a class="header" href="#questions-about-your-function-signatures">Questions about your function signatures</a></h1>
<h2 id="should-i-return-an-iterator-or-a-collection"><a class="header" href="#should-i-return-an-iterator-or-a-collection">Should I return an iterator or a collection?</a></h2>
<blockquote>
<p>Pretty much always return an iterator. - AH</p>
</blockquote>
<p>We suggested you <a href="./code.html#how-can-i-avoid-the-performance-penalty-of-bounds-checks">use iterators a lot in your code</a>. Share the love! Give iterators to your callers too.</p>
<p>If you <em>know</em> your caller will store the items you're returning in a concrete collection, such as a <code>Vec</code> or a <code>HashSet</code>, you may want to return that. In all other cases, return an iterator.</p>
<p>Your caller might:</p>
<ul>
<li>Collect the iterator into a <code>Vec</code></li>
<li>Collect it into a <code>HashSet</code> or some other specialized container</li>
<li>Loop over the items</li>
<li>Filter them or otherwise completely ignore some</li>
</ul>
<p>Collecting the items into vector will only turn out to be right in one of these cases. In the other cases, you're wasting memory and CPU time by building a concrete collection.</p>
<p>This is weird for C++ programmers because iterators don't usually have robust references into the underlying data. Even Java iterators are scary, throwing <code>ConcurrentModificationExceptions</code> when you least expect it. Rust prevents that, at compile time. If you <em>can</em> return an iterator, you should.</p>
<pre class="mermaid">flowchart LR
    subgraph Caller
    it_ref[reference to iterator]
    end
    subgraph it_outer[Iterator]
    it[Iterator]
    it_ref --reference--&gt; it
    end
    subgraph data[Underlying data]
    dat[Underlying data]
    it --reference--&gt; dat
    end
</pre>
<h2 id="how-flexible-should-my-parameters-be"><a class="header" href="#how-flexible-should-my-parameters-be">How flexible should my parameters be?</a></h2>
<p>Which of these is best?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn a(params: &amp;[String]) {
    // ...
}

fn b(params: &amp;[&amp;str]) {
    // ...
}

fn c(params: &amp;[impl AsRef&lt;str&gt;]) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>(You'll need to make an equivalent decision in other cases, e.g. <code>Path</code> versus <code>PathBuf</code> versus <code>AsRef&lt;Path&gt;</code>.)</p>
<p>None of the options is clearly superior; for each option, there's a case it can't handle that the others can:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn a(params: &amp;[String]) {
</span><span class="boring">}
</span><span class="boring">fn b(params: &amp;[&amp;str]) {
</span><span class="boring">}
</span><span class="boring">fn c(params: &amp;[impl AsRef&lt;str&gt;]) {
</span><span class="boring">}
</span>fn main() {
    a(&amp;[]);
    // a(&amp;[&quot;hi&quot;]); // doesn't work
    a(&amp;vec![format!(&quot;hello&quot;)]);

    b(&amp;[]);
    b(&amp;[&quot;hi&quot;]);
    // b(&amp;vec![format!(&quot;hello&quot;)]); // doesn't work

    // c(&amp;[]); // doesn't work
    c(&amp;[&quot;hi&quot;]);
    c(&amp;vec![format!(&quot;hello&quot;)]);
}
</code></pre></pre>
<p>So you have a variety of interesting ways to <em>slightly</em> annoy your callers under different circumstances. Which is best?</p>
<p><code>AsRef</code> has some advantages: if a caller has a <code>Vec&lt;String&gt;</code>, they can use that directly, which would be impossible with the other options. But if they want to pass an empty list, they'll have to explicitly specify the type (for instance <code>&amp;Vec::&lt;String&gt;::new()</code>).</p>
<blockquote>
<p>Not a huge fan of AsRef everywhere - it's just saving the caller typing. If you have lots of AsRef then nothing is object-safe. - MG</p>
</blockquote>
<p>TL;DR: choose the middle option, <code>&amp;[&amp;str]</code>. If your caller happens to have a vector of <code>String</code>, it's relatively little work to get a slice of <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn b(params: &amp;[&amp;str]) {
</span><span class="boring">}
</span>
fn main() {
    // Instead of b(&amp;vec![format!(&quot;hello&quot;)]);
    let hellos = vec![format!(&quot;hello&quot;)];
    b(&amp;hellos.iter().map(String::as_str).collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<h2 id="how-do-i-overload-constructors"><a class="header" href="#how-do-i-overload-constructors">How do I overload constructors?</a></h2>
<p>You can't do this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct BirthdayCard {}
</span>impl BirthdayCard {
    fn new(name: &amp;str) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }

    // Can't add more overloads:
    //
    // fn new(name: &amp;str, age: i32) -&gt; BirthdayCard { ... }
    //
    // fn new(name: &amp;str, text: &amp;str) -&gt; BirthdayCard { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have a default constructor, and a few variants for other cases, you can simply write them as different static methods. An idiomatic way to do this is to write a <code>new()</code> constructor and then <code>with_foo()</code> constructors that apply the given &quot;foo&quot; when constructing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Racoon {}
</span>impl Racoon {
    fn new() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
    fn with_age(age: usize) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have have a bunch of constructors and no default, it may make sense to instead provide a set of <code>new_foo()</code> constructors.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Animal {}
</span>impl Animal {
    fn new_squirrel() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
    fn new_badger() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For a more complex situation, you may use <a href="https://rust-lang.github.io/api-guidelines/type-safety.html#builders-enable-construction-of-complex-values-c-builder">the builder pattern</a>. The builder has a set of methods which take <code>&amp;mut self</code> and return <code>&amp;mut Self</code>. Then add a <code>build()</code> that returns the final constructed object.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BirthdayCard {}

struct BirthdayCardBuilder {}
impl BirthdayCardBuilder {
    fn new(name: &amp;str) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }

    fn age(&amp;mut self, age: i32) -&gt; &amp;mut Self {
<span class="boring">        self
</span>        // ...
    }

    fn text(&amp;mut self, text: &amp;str) -&gt; &amp;mut Self {
<span class="boring">        self
</span>        // ...
    }

    fn build(&amp;mut self) -&gt; BirthdayCard { BirthdayCard { /* ... */ } }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can then <a href="https://rust-lang.github.io/api-guidelines/type-safety.html#non-consuming-builders-preferred">chain these</a> into short or long constructions, passing parameters as necessary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct BirthdayCard {}
</span><span class="boring">
</span><span class="boring">struct BirthdayCardBuilder {}
</span><span class="boring">impl BirthdayCardBuilder {
</span><span class="boring">    fn new(name: &amp;str) -&gt; BirthdayCardBuilder {
</span><span class="boring">      Self{}
</span><span class="boring">      // ...
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn age(&amp;mut self, age: i32) -&gt; &amp;mut BirthdayCardBuilder {
</span><span class="boring">        self
</span><span class="boring">        // ...
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn text(&amp;mut self, text: &amp;str) -&gt; &amp;mut BirthdayCardBuilder {
</span><span class="boring">        self
</span><span class="boring">        // ...
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn build(&amp;mut self) -&gt; BirthdayCard { BirthdayCard { /* ... */ } }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let card = BirthdayCardBuilder::new(&quot;Paul&quot;)
        .age(64)
        .text(&quot;Happy Valentine's Day!&quot;)
        .build();
}
</code></pre></pre>
<p>Note another advantage of builders: Overloaded constructors often don't provide all possible combinations of parameters, whereas with the builder pattern, you can combine exactly the parameters you want.</p>
<h2 id="when-must-i-use-must_use"><a class="header" href="#when-must-i-use-must_use">When must I use <code>#[must_use]</code>?</a></h2>
<blockquote>
<p>Use it on Results and mutex locks. - MG</p>
</blockquote>
<p><code>#[must_use]</code> causes a compile error if the caller ignores the return value.</p>
<p>Rust functions are often single-purpose. They either:</p>
<ul>
<li>Return a value without any side effects; or</li>
<li>Do something (i.e. have side effects) and return nothing.</li>
</ul>
<p>In neither case do you need to think about <code>#[must_use]</code>. (In the first case,
nobody would call your function unless they were going to use the result.)</p>
<p><code>#[must_use]</code> is useful for those rarer functions which return a result <em>and</em>
have side effects. In most such cases, it's wise to specify <code>#[must_use]</code>, unless
the return value is truly optional (for example in
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert"><code>HashMap::insert</code></a>).</p>
<h2 id="when-should-i-take-parameters-by-value"><a class="header" href="#when-should-i-take-parameters-by-value">When should I take parameters by value?</a></h2>
<p>Move semantics are more common in Rust than in C++.</p>
<blockquote>
<p>In C++ moves tend to be an optimization, whereas in Rust they're a key semantic part of the program. - MY</p>
</blockquote>
<p>To a first approximation, you should assume similar performance when passing
things by (moved) value or by reference. It's true that a move may turn out to
be a <code>memcpy</code>, but it's often optimized away.</p>
<blockquote>
<p>Express the ownership relationship in the type system, instead of trying to second-guess the compiler for efficiency. - AF</p>
</blockquote>
<p>The moves are, of course, destructive - and unlike in C++, the compiler
enforces that you don't reuse a variable that has been moved.
Some C++ objects become toxic after they've moved; that's not a
risk in Rust.</p>
<p>So here's the heuristic: if a caller shouldn't be able to use an object again,
pass it via move semantics in order to consume it.</p>
<p>An extreme example: a UUID is supposed to be globally unique - it might cause a
logic error for a caller to retain knowledge of a UUID after passing it to a callee.</p>
<p>More generally, consume data enthusiastically to avoid logical errors during future
refactorings. For instance, if some command-line options are overridden by a
runtime choice, consume those old options - then any future refactoring which
uses them after that point will give you a compile error. This pattern is
surprisingly effective at spotting errors in your assumptions.</p>
<h2 id="should-i-ever-take-self-by-value"><a class="header" href="#should-i-ever-take-self-by-value">Should I ever take <code>self</code> by value?</a></h2>
<p>Sometimes. If you've got a member function which destroys or transforms a thing,
it should take <code>self</code> by value. Examples:</p>
<ul>
<li>Closing a file and returning a result code.</li>
<li>A builder-pattern object which spits out the thing it was building. (<a href="https://docs.rs/bindgen/0.59.0/bindgen/struct.Builder.html#method.generate">Example</a>).</li>
</ul>
<h2 id="should-i-return-an-error-or-panic"><a class="header" href="#should-i-return-an-error-or-panic">Should I return an error, or panic?</a></h2>
<p>Panics should be used only for invariants, never for anything that you believe
might happen. That's especially true <a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">for libraries</a></p>
<ul>
<li>panicking (or asserting) should be reserved for the 'top level' code driving
the application.</li>
</ul>
<blockquote>
<p>Libraries which panic are super-rude and I hate them - MY</p>
</blockquote>
<p>Even in your own application code, panicking might not be wise:</p>
<blockquote>
<p>Panicking in application logic for recoverable errors makes it way harder to librarify some code - AP</p>
</blockquote>
<p>If you really must have an API which can panic, add a <code>try_</code> equivalent too.</p>
<h2 id="what-should-my-error-type-be"><a class="header" href="#what-should-my-error-type-be">What should my error type be?</a></h2>
<p><a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code> type</a> is parameterized
over an error type. What should you use?</p>
<p>For app code, consider <a href="https://docs.rs/anyhow/">anyhow</a>. For library code,
use your own <code>enum</code> of error conditions - you can use <a href="https://docs.rs/thiserror/">thiserror</a>
to make this more pleasant.</p>
<h2 id="when-should-i-take-or-return-dyn-trait"><a class="header" href="#when-should-i-take-or-return-dyn-trait">When should I take or return <code>dyn Trait</code>?</a></h2>
<p>In either C++ or Rust, you can choose between monomorphization (that is, building
code multiple times for each permutation of parameter types) or dynamic dispatch (i.e.
looking up the correct implementation using vtables).</p>
<p>In C++ the syntax is completely different - templates vs virtual functions.
In Rust the syntax is almost identical - in some cases it's as simple as
exchanging the <code>impl</code> keyword with the <code>dyn</code> keyword.</p>
<p>Given this flexibility to switch strategies, which should you start with?</p>
<p>In both languages, monomorphization tends to result in a quicker program (partly
due to better inlining). It's arguably true that inlining is more important in
Rust, due to its functional nature and pervasive use of iterators. Whether or
not that's the reason, experienced Rustaceans usually start with <code>impl</code>:</p>
<blockquote>
<p>It's best practice to start with monomorphization and move to <code>dyn</code>... - MG</p>
</blockquote>
<p>The main cost of monomorphization is larger binaries. There are cases where
large amounts of code can end up being duplicated (the marvellous <a href="https://serde.rs/">serde</a>
is one).</p>
<p>You <em>can</em> choose to do things the other way round:</p>
<blockquote>
<p>... it’s workable practice to start with <code>dyn</code> and then move to <code>impl</code> when you have problems. - MG</p>
</blockquote>
<p><code>dyn</code> can be awkward, and potentially expensive in different ways:</p>
<blockquote>
<p>One thing to note about pervasive <code>dyn</code> is that because it unsizes the types it wraps, you need to box it if you want to store it by value. You end up with a good bit more allocator pressure if you try to have <code>dyn</code> field types. - AP</p>
</blockquote>
<h2 id="ai-seem-to-have-lots-of-named-lifetimes-am-bi-doing-something-wrong"><a class="header" href="#ai-seem-to-have-lots-of-named-lifetimes-am-bi-doing-something-wrong"><code>&lt;'a&gt;</code>I seem to have lots of named lifetimes. Am <code>&lt;'b&gt;</code>I doing something wrong?</a></h2>
<p>Some say that if you have a significant number of named lifetimes, you're
overcomplicating things.</p>
<p>There are some scenarios where multiple named lifetimes make perfect sense - for example
if you're dealing with an arena, or major phases of a process (the Rust compiler
has <code>'gcx</code> and <code>'tcx</code> lifetimes relating to the output of certain compile phases.)</p>
<p>But otherwise, it may be that you've got lifetimes because you're trying <em>too
hard</em> to avoid a copy. You may be better off simply switching to runtime
checking (e.g. <code>Rc</code>, <code>Arc</code>) or even cloning.</p>
<p>Are named lifetimes even a &quot;code smell&quot;?</p>
<blockquote>
<p>My experience has been that the extent to which they're a smell varies a good bit based on the programmer's experience level, which has led me towards increased skepticism over time. Lots of people learning Rust have experienced the pain of first not wanting to <code>.clone()</code> something, immediately putting lifetimes everywhere, and then feeling the pain of lifetime subtyping and variance. I don't think they're nearly as odorous as unsafe, for example, but treating them as a bit of a smell does I think lead to code that's easier to read for a newcomer and to refactor around the stack. - AP</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="code.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="code.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="third_party/mermaid/mermaid.min.js"></script>
                <script type="text/javascript" src="third_party/mermaid/mermaid-init.js"></script>
        
        
    </body>
</html>
