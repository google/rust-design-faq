<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Questions about your whole codebase - cppfaq.rs</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="code.html"><strong aria-hidden="true">2.</strong> Questions about code in function bodies</a></li><li class="chapter-item expanded "><a href="signatures.html"><strong aria-hidden="true">3.</strong> Questions about your function signatures</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Questions about your types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Questions about your APIs</div></li><li class="chapter-item expanded "><a href="codebase.html" class="active"><strong aria-hidden="true">6.</strong> Questions about your whole codebase</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Questions about your processes</div></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">cppfaq.rs</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/google/rust-design-faq" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="questions-about-your-whole-codebase"><a class="header" href="#questions-about-your-whole-codebase">Questions about your whole codebase</a></h1>
<h2 id="the-c-observer-pattern-is-hard-in-rust-what-to-do"><a class="header" href="#the-c-observer-pattern-is-hard-in-rust-what-to-do">The C++ observer pattern is hard in Rust. What to do?</a></h2>
<p>The C++ observer pattern usually means that there are broadcasters sending messages to consumers:</p>
<pre class="mermaid">flowchart TB
    broadcaster_a[Broadcaster A]
    broadcaster_b[Broadcaster B]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    consumer_c[Consumer C]
    broadcaster_a --&gt; consumer_a
    broadcaster_b --&gt; consumer_a
    broadcaster_a --&gt; consumer_b
    broadcaster_b --&gt; consumer_b
    broadcaster_a --&gt; consumer_c
    broadcaster_b --&gt; consumer_c
</pre>
<p>The broadcasters maintain lists of consumers, and the consumers act in response to messages (often mutating their own state.)</p>
<p>This doesn't work in Rust, because it requires the broadcasters to hold mutable references to the consumers.</p>
<p>What do you do?</p>
<h3 id="option-1-make-everything-runtime-checked"><a class="header" href="#option-1-make-everything-runtime-checked">Option 1: make everything runtime-checked</a></h3>
<p>Each of your consumers could become an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> or, if you need thread-safety, an <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>.</p>
<p>The <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> allows broadcasters to share ownership of a consumer. The <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a> allows each broadcaster to acquire a mutable reference to a consumer when it needs to send a message.</p>
<p>This example shows how, in Rust, you <a href="https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">may independently choose reference counting <em>or</em> interior mutability</a>. In this case we need both.</p>
<p>Just like typical reference counting in C++, <code>Rc</code> and <code>Arc</code> have the option to provide a weak pointer, so the lifetime of each consumer doesn't need to be extended unnecessarily. As an aside, it would be nice if Rust had an <code>Rc</code>-like type which enforces exactly one owner, and multiple weak ptrs. <code>Rc</code> could be wrapped quite easily to do this.</p>
<p>Reference counting is frowned-upon in C++ because it's expensive. But, in Rust, not so much:</p>
<ul>
<li>Few objects are reference counted; the majority of objects are owned statically.</li>
<li>Even when objects are reference counted, those counts are rarely incremented and decremented because you can (and do) pass around <code>&amp;Rc&lt;RefCell&lt;T&gt;&gt;</code> most of the time. In C++, the &quot;copy by default&quot; mode means it's much more common to increment and decrement reference counts.</li>
</ul>
<p>In fact, the compile-time guarantees might cause you to do <em>less</em> reference counting than C++:</p>
<blockquote>
<p>In Servo there is a reference count but far fewer objects are reference counted than in the rest of Firefox, because you don’t need to be paranoid - MG</p>
</blockquote>
<p>However: Rust does <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">not prevent reference cycles</a>, although they're only possible if you're using <em>both</em> reference counting and interior mutability.</p>
<h3 id="option-2-drive-the-objects-from-the-code-not-the-other-way-round"><a class="header" href="#option-2-drive-the-objects-from-the-code-not-the-other-way-round">Option 2: drive the objects from the code, not the other way round</a></h3>
<p>In C++, it's common to have all behavior within classes. Those classes <em>are</em> the total behavior of the system, and so they must interact with one another. The observer pattern is common.</p>
<pre class="mermaid">flowchart TB
    broadcaster_a[Broadcaster A]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    broadcaster_a -- observer --&gt; consumer_a
    broadcaster_a -- observer --&gt; consumer_b
</pre>
<p>In Rust, it's more common to have some <em>external</em> function which drives overall behavior.</p>
<pre class="mermaid">flowchart TB
    main(Main)
    broadcaster_a[Broadcaster A]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    main --1--&gt; broadcaster_a
    broadcaster_a --2--&gt; main
    main --3--&gt; consumer_a
    main --4--&gt; consumer_b
</pre>
<p>With this sort of design, it's relatively straightforward to take some output from one object and pass it into another object, with no need for the objects to interact at all.</p>
<p>In the most extreme case, this becomes the <a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity-Component-System architecture</a> used in game design.</p>
<blockquote>
<p>Game developers seem to have completely solved this problem - we can learn from them. - MY</p>
</blockquote>
<h3 id="option-3-use-channels"><a class="header" href="#option-3-use-channels">Option 3: use channels</a></h3>
<p>The observer pattern is a way to decouple large, single-threaded C++ codebases. But if you're trying to decouple a codebase in Rust, perhaps you should assume multi-threading by default? Rust has built-in <a href="https://doc.rust-lang.org/std/sync/mpsc/">channels</a>, and the <a href="https://docs.rs/crossbeam/0.8.0/crossbeam/">crossbeam</a> crate provides multi-producer, multi-consumer channels.</p>
<blockquote>
<p>I'm a Rustacean, we assume massively parallel unless told otherwise :) - MG</p>
</blockquote>
<h2 id="thats-all-very-well-but-i-have-an-existing-c-object-broadcasting-events-how-exactly-should-i-observe-it"><a class="header" href="#thats-all-very-well-but-i-have-an-existing-c-object-broadcasting-events-how-exactly-should-i-observe-it">That's all very well, but I have an existing C++ object broadcasting events. How exactly should I observe it?</a></h2>
<p>If your Rust object is a consumer of events from some pre-existing C++ producer, all the above options remain possible.</p>
<ul>
<li>You can make your object reference counted and have C++ own such a reference (potentially a weak reference)</li>
<li>C++ can deliver the message into a general message bucket. An external function reads messages from that bucket and invokes the Rust object that should handle it. This means the reference counting doesn't need to extend to the Rust objects outside that boundary layer.</li>
<li>You can have a shim object which converts the C++ callback into some message and injects it into a channel-based world.</li>
</ul>
<h2 id="some-of-my-c-objects-have-shared-mutable-state-how-can-i-make-them-safe-in-rust"><a class="header" href="#some-of-my-c-objects-have-shared-mutable-state-how-can-i-make-them-safe-in-rust">Some of my C++ objects have shared mutable state. How can I make them safe in Rust?</a></h2>
<p>You're going to have to do something with <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>: either <code>RefCell&lt;T&gt;</code> or its multithreaded equivalent, <code>RwLock&lt;T&gt;</code>.</p>
<p>You have three decisions to make:</p>
<ol>
<li>Will only Rust code access <em>this particular instance</em> of this object, or might C++ access it too?</li>
<li>If both C++ and Rust may access the object, how do you avoid conflicts?</li>
<li>How should Rust code react if the object is not available, because something else is using it?</li>
</ol>
<p>If only Rust code can use this particular instance of shared state, then simply wrap it in <code>RefCell&lt;T&gt;</code> (single-threaded) or <code>RwLock&lt;T&gt;</code> (multi-threaded). Build a wrapper type such that callers aren't able to access the object directly, but instead only via the lock type.</p>
<p>If C++ also needs to access this particular instance of the shared state, it's more complex. There are presumably some invariants regarding use of this data in C++ - otherwise it would crash all the time. Perhaps the data can be used only from one thread, or perhaps it can only be used with a given mutex held. Your goal is to translate those invariants into an idiomatic Rust API that can be checked (ideally) at compile-time, and (failing that) at runtime.</p>
<p>For example, imagine:</p>
<pre><code class="language-cpp">class SharedMutableGoat {
public:
    void eat_grass(); // mutates tummy state
};

std::mutex lock;
SharedMutableGoat* billy; // only access when owning lock
</code></pre>
<p>Your idiomatic Rust wrapper might be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ffi {
</span><span class="boring">  #[allow(non_camel_case_types)]
</span><span class="boring">  pub struct lock_guard;
</span><span class="boring">  pub fn claim_lock() -&gt; lock_guard { lock_guard{} }
</span><span class="boring">  pub fn eat_grass() {}
</span><span class="boring">  pub fn release_lock(lock: &amp;mut lock_guard) {}
</span><span class="boring">}
</span>struct SharedMutableGoatLock {
    lock: ffi::lock_guard, // owns a std::lock_guard&lt;std::mutex&gt; somehow
};

// Claims the lock, returns a new SharedMutableGoatLock
fn lock_shared_mutable_goat() -&gt; SharedMutableGoatLock {
    SharedMutableGoatLock { lock: ffi::claim_lock() }
}

impl SharedMutableGoatLock {
    fn eat_grass(&amp;mut self) {
        ffi::eat_grass(); // Acts on the global goat
    }
}

impl Drop for SharedMutableGoatLock {
    fn drop(&amp;mut self) {
        ffi::release_lock(&amp;mut self.lock);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Obviously, lots of permutations are possible, but the goal is to ensure that it's simply compile-time impossible to act on the global state unless appropriate preconditions are met.</p>
<p>The final decision is how to react if the object is not available. This decision can apply with C++ mutexes or with Rust locks (for example <code>RwLock&lt;T&gt;</code>). As in C++, the two major options are:</p>
<ul>
<li>Block until the object becomes available.</li>
<li>Try to lock, and if the object is not available, do something else.</li>
</ul>
<p>There can be a third option if you're using async Rust. If the data isn't available, you may be able to return to your event loop using an async version of the lock (<a href="https://docs.rs/tokio/1.5.0/tokio/sync/struct.RwLock.html#method.read">Tokio example</a>, <a href="https://docs.rs/async-std/1.9.0/async_std/sync/struct.RwLock.html">async_std example</a>).</p>
<h2 id="how-do-i-do-a-singleton"><a class="header" href="#how-do-i-do-a-singleton">How do I do a singleton?</a></h2>
<p>Use <a href="https://docs.rs/once_cell/1.7.2/once_cell/">OnceCell</a> for now. <a href="https://doc.rust-lang.org/std/lazy/struct.Lazy.html">This should arrive in the standard library</a> in future.</p>
<h2 id="whats-the-best-way-to-retrofit-rusts-parallelism-benefits-to-an-existing-codebase"><a class="header" href="#whats-the-best-way-to-retrofit-rusts-parallelism-benefits-to-an-existing-codebase">What's the best way to retrofit Rust's parallelism benefits to an existing codebase?</a></h2>
<p>When parallelizing an existing codebase, first check that all existing types are correctly <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>. Generally, though, you should try to avoid implementing these yourself - instead use pre-existing wrapper types which enforce the correct contract (for example, <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>).</p>
<p>After that:</p>
<blockquote>
<p>If you can solve your problem by throwing Rayon at it, do. It’s magic - MG</p>
</blockquote>
<blockquote>
<p>If your task is CPU-bound, Rayon solves this handily. - MY</p>
</blockquote>
<p><a href="https://docs.rs/rayon/1.5.0/rayon/">Rayon</a> offers parallel constructs - for example parallel iterators - which can readily be retrofitted to an existing codebase. It also allows you to create and join tasks. Using Rayon can help <em>simplify</em> your code and eliminate lots of manual scheduling logic.</p>
<p>If your tasks are IO-bound, then you may need to look into async Rust, but that's hard to pull into an existing codebase.</p>
<h2 id="whats-the-best-way-to-architect-a-new-codebase-for-parallelism"><a class="header" href="#whats-the-best-way-to-architect-a-new-codebase-for-parallelism">What's the best way to architect a new codebase for parallelism?</a></h2>
<p>In brief, like in other languages, you have a choice of architectures:</p>
<ul>
<li>Message-passing, using event loops which listen on a channel, receive <code>Send</code> data and pass it on.</li>
<li>More traditional multithreading using <code>Sync</code> data structures such as mutexes (and perhaps Rayon).</li>
</ul>
<blockquote>
<p>There's probably a bias towards message-passing, and that's probably well-informed by its extensibility. - MG</p>
</blockquote>
<h2 id="i-need-a-list-of-nodes-which-can-refer-to-one-another-how"><a class="header" href="#i-need-a-list-of-nodes-which-can-refer-to-one-another-how">I need a list of nodes which can refer to one another. How?</a></h2>
<p>You can't easily do self-referential data structures in Rust. The usual workaround is to <a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/">use an arena</a> and replace references from one node to another with node IDs.</p>
<p>An arena is typically a <code>Vec</code> (or similar), and the node IDs are a newtype wrapper around a simple integer index.</p>
<p>Obviously, Rust doesn't check that your node IDs are valid. If you don't have proper references, what stops you from having stale IDs?</p>
<p>Arenas are often purely additive, which means that you can add entries but not delete them (<a href="https://github.com/Manishearth/elsa/blob/master/examples/mutable_arena.rs">example</a>). If you must have an arena which deletes things, then use generational IDs; see the <a href="https://docs.rs/generational-arena/">generational-arena</a> crate and this <a href="https://www.youtube.com/watch?v=aKLntZcp27M">RustConf keynote</a> for more details.</p>
<p>If arenas still sound like a nasty workaround, consider that you might choose an arena anyway for other reasons:</p>
<ul>
<li>All of the objects in the arena will be freed at the end of the arena's lifetime, instead of during their manipulation, which can give very low latency for some use-cases. <a href="https://docs.rs/bumpalo/3.6.1/bumpalo/">Bumpalo</a> formalizes this.</li>
<li>The rest of your program might have real Rust references into the arena. You can give the arena a named lifetime (<code>\</code>arena` for example), making the provenance of those references very clear.</li>
</ul>
<h2 id="im-having-a-miserable-time-making-my-data-structure-should-i-use-unsafe"><a class="header" href="#im-having-a-miserable-time-making-my-data-structure-should-i-use-unsafe">I'm having a miserable time making my data structure. Should I use unsafe?</a></h2>
<p>Low-level data structures are <em>hard</em> in Rust. Arguably, Rust merely makes plain
all the lifetime and ownership issues which you already had in other languages, but
the compiler is brutal about it, and you're going to have a bad day.</p>
<p>Even something as simple as a doubly-linked list is notoriously hard; so much so
that there is a <a href="https://rust-unofficial.github.io/too-many-lists/">book that teaches Rust based solely on linked lists</a>.
As that (wonderful) book makes clear, you are often faced with a choice:</p>
<ul>
<li><a href="https://rust-unofficial.github.io/too-many-lists/fourth.html">Use safe Rust, but shift compile-time checks to runtime</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/fifth.html">Use <code>unsafe</code></a> and
take the same degree of care you'd take in C or C++. And, just like in C or C++,
you'll introduce <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-19029/product_id-48677/Rust-lang-Rust.html">security vulnerabilities in the unsafe code</a>.</li>
</ul>
<p>If you're facing this decision... perhaps there's a third way.</p>
<p>You should almost always be using somebody else's tried-and-tested
data structure.</p>
<p><a href="https://docs.rs/petgraph">petgraph</a> and
<a href="https://docs.rs/slotmap">slotmap</a> are great examples. Use someone else's crate
by default, and resort to writing your own only if you exhaust that option.</p>
<p>C++ makes it hard to pull in third-party dependencies, so it's culturally normal
to write new code. Rust makes it trivial to add dependencies, and so you will
need to do that, even if it feels awkward for a C++ programmer.</p>
<p>This <em>ease</em> of adding dependencies <strong>co-evolved</strong> with the
<em>difficulty</em> of making data structures. It's simply a part of programming in Rust.
You just can't separate the language and the ecosystem.</p>
<p>You might argue that this dependency on third-party crates is concerning
from a supply-chain security point of view. Your author would agree, but
it's just the way you do things in Rust. Stop creating your own data structures.</p>
<h2 id="should-i-have-a-few-big-crates-or-lots-of-small-ones"><a class="header" href="#should-i-have-a-few-big-crates-or-lots-of-small-ones">Should I have a few big crates or lots of small ones?</a></h2>
<p>In the past, it was recommended to have small crates to get optimal build time.
Incremental builds generally make this unnecessary now. You should arrange your
crates optimally for your semantic needs.</p>
<h2 id="what-crates-should-everyone-know-about"><a class="header" href="#what-crates-should-everyone-know-about">What crates should everyone know about?</a></h2>
<table><thead><tr><th align="left">Crate</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><a href="https://docs.rs/rayon/">rayon</a></td><td align="left">parallelizing</td></tr>
<tr><td align="left"><a href="https://docs.rs/serde/">serde</a></td><td align="left">serializing and deserializing</td></tr>
<tr><td align="left"><a href="https://docs.rs/crossbeam/">crossbeam</a></td><td align="left">all sorts of parallelism tools</td></tr>
<tr><td align="left"><a href="https://docs.rs/itertools/">itertools</a></td><td align="left">makes it slightly more pleasant to work with iterators. (For instance, if you want to join an iterator of strings, you can just go ahead and do that, without needing to collect the strings into a <code>Vec</code> first)</td></tr>
<tr><td align="left"><a href="https://docs.rs/petgraph/">petgraph</a></td><td align="left">graph data structures</td></tr>
<tr><td align="left"><a href="https://docs.rs/slotmap/">slotmap</a></td><td align="left">arena-like key-value map</td></tr>
<tr><td align="left"><a href="https://docs.rs/nom/">nom</a></td><td align="left">parsing</td></tr>
<tr><td align="left"><a href="https://docs.rs/clap/">clap</a></td><td align="left">command-line parsing</td></tr>
<tr><td align="left"><a href="https://docs.rs/regex/">regex</a></td><td align="left">err, regular expressions</td></tr>
<tr><td align="left"><a href="https://docs.rs/ring/">ring</a></td><td align="left">the leading crypto library</td></tr>
<tr><td align="left"><a href="https://docs.rs/nalgebra/">nalgebra</a></td><td align="left">linear algebra</td></tr>
<tr><td align="left"><a href="https://docs.rs/once_cell/">once_cell</a></td><td align="left">complex static data</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="signatures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="signatures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="third_party/mermaid/mermaid.min.js"></script>
                <script type="text/javascript" src="third_party/mermaid/mermaid-init.js"></script>
        
        
    </body>
</html>
