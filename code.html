<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Questions about code in function bodies - cppfaq.rs</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="code.html" class="active"><strong aria-hidden="true">2.</strong> Questions about code in function bodies</a></li><li class="chapter-item expanded "><a href="signatures.html"><strong aria-hidden="true">3.</strong> Questions about your function signatures</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">4.</strong> Questions about your types</a></li><li class="chapter-item expanded "><a href="apis.html"><strong aria-hidden="true">5.</strong> Questions about your APIs</a></li><li class="chapter-item expanded "><a href="codebase.html"><strong aria-hidden="true">6.</strong> Questions about your whole codebase</a></li><li class="chapter-item expanded "><a href="processes.html"><strong aria-hidden="true">7.</strong> Questions about your processes</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">cppfaq.rs</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/google/rust-design-faq" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="questions-about-code-in-function-bodies"><a class="header" href="#questions-about-code-in-function-bodies">Questions about code in function bodies</a></h1>
<h2 id="how-can-i-avoid-the-performance-penalty-of-bounds-checks"><a class="header" href="#how-can-i-avoid-the-performance-penalty-of-bounds-checks">How can I avoid the performance penalty of bounds checks?</a></h2>
<p>Rust array and list accesses are all bounds checked. You may be worried about a performance penalty. How can you avoid that?</p>
<blockquote>
<p>Contort yourself a little bit to use iterators. - MY</p>
</blockquote>
<p>Rust gives you choices around functional versus imperative style, but things often work better in a functional style. Specifically - if you've got something iterable, then there are probably functional methods to do what you want.</p>
<p>For instance, suppose you need to work out what food to get at the petshop. Here's code that does this in an imperative style:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_a() -&gt; HashSet&lt;&amp;'static str&gt; {
    let mut meals_needed = HashSet::new();
    for n in 0..PETS.len() { // ugh
        if PETS[n].is_hungry {
            meals_needed.insert(PETS[n].meal_needed);
        }
    }
    meals_needed
}
<span class="boring">}
</span></code></pre></pre>
<p>The loop index is verbose and error-prone. Let's get rid of it and loop over an iterator instead:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_b() -&gt; HashSet&lt;&amp;'static str&gt;  {
    let mut meals_needed = HashSet::new();
    for animal in PETS.iter() { // better...
        if animal.is_hungry {
            meals_needed.insert(animal.meal_needed);
        }
    }
    meals_needed
}
<span class="boring">}
</span></code></pre></pre>
<p>We're accessing the loop through an iterator, but we're still processing the elements inside a loop. It's often more idiomatic to replace the loop with a chain of iterators:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_c() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect() // best...
}
<span class="boring">}
</span></code></pre></pre>
<p>The obvious advantage of the third approach is that it's more concise, but less obviously:</p>
<ul>
<li>The first solution may require Rust to do array bounds checks inside each iteration of the loop, making Rust potentially slower than C++. In this sort of simple example, it likely wouldn't, but functional pipelines simply don't require bounds checks.</li>
<li>The final container (a <code>HashSet</code> in this case) may be able to allocate roughly the right size at the outset, using the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint">size_hint</a> of a Rust iterator.</li>
<li>If you use iterator-style code rather than imperative code, it's more likely the Rust compiler will be able to <a href="https://medium.com/swlh/an-adventure-in-simd-b0e8db4ccca7">auto-vectorize using SIMD instructions</a>.</li>
<li>There is no mutable state within the function. This makes it easier to verify that the code is correct and to avoid introducing bugs when changing it. In this simple example it may be obvious that calling the <code>HashSet::insert</code> is the only mutation to the set, but in more complex scenarios it is quite easy to lose the overview.</li>
<li>And as a new arrival from C++, you may find this hard to believe: For an experienced Rustacean it'll be more readable.</li>
</ul>
<p>Here are some more iterator techniques to help avoid materializing a collection:</p>
<ul>
<li>
<p>You can <a href="https://doc.rust-lang.org/std/iter/struct.Chain.html">chain two iterators together</a> to make a longer one.</p>
</li>
<li>
<p>If you need to iterate two lists, <a href="https://doc.rust-lang.org/std/iter/struct.Zip.html">zip them together</a> to avoid bounds checks on either.</p>
</li>
<li>
<p>If you want to feed all your animals, and also feed a nearby duck, just chain the iterator to <code>std::iter::once</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">static PETS: [Animal; 0] = [];
</span><span class="boring"> static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">        kind: &quot;Duck&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;pondweed&quot;,
</span><span class="boring">    };
</span>fn make_shopping_list_d() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .chain(std::iter::once(&amp;NEARBY_DUCK))
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>(Similarly, if you want to add one more item to the shopping list - maybe you're hungry, as well as your menagerie? - just add it after the <code>map</code>).</p>
</li>
<li>
<p><code>Option</code> is iterable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">static PETS: [Animal; 0] = [];
</span><span class="boring">struct Pond;
</span><span class="boring">static MY_POND: Pond = Pond;
</span>fn pond_inhabitant(pond: &amp;Pond) -&gt; Option&lt;&amp;Animal&gt; {
    // ...
<span class="boring">   None
</span>}

fn make_shopping_list_e() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .chain(pond_inhabitant(&amp;MY_POND))
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>Here's a diagram showing how data flows in this iterator pipeline:</p>
</li>
</ul>
<pre class="mermaid">flowchart LR
    %%{ init: { 'flowchart': { 'nodeSpacing': 40, 'rankSpacing': 15 } } }%%
      Pets
      Filter([filter by hunger])
      Map([map to noms])
      Meals
      uniqueify([uniqueify])
      shopping[Shopping list]
      Pets ---&gt; Filter
      Pond
      Pond ---&gt; inhabitant
      inhabitant[Optional pond inhabitant]
      inhabitant ---&gt; Map
      Filter ---&gt; Map
      Map ---&gt; Meals
      Meals ---&gt; uniqueify
      uniqueify ---&gt; shopping
</pre>
<ul>
<li>Here are other iterator APIs that will come in useful:
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned">cloned</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten">flatten</a></li>
</ul>
</li>
</ul>
<p>C++20 recently introduced <a href="https://en.cppreference.com/w/cpp/ranges">ranges</a>, a feature that allows you to pipeline operations on a collection similar to the way Rust iterators do, so this style of programming is likely to become more common in C++ too.</p>
<p>To summarize: While in C++ you tend to operate on collections by performing a series of operations on each individual item, in Rust you'll typically apply a pipeline of operations to the whole collection. Make this mental switch and your code will not just become more idiomatic but more efficient, too.</p>
<h2 id="isnt-it-confusing-to-use-the-same-variable-name-twice"><a class="header" href="#isnt-it-confusing-to-use-the-same-variable-name-twice">Isn't it confusing to use the same variable name twice?</a></h2>
<p>In Rust, it's common to reuse the same name for multiple variables in a function. For a C++ programmer, this is weird, but there are two good reasons to do it:</p>
<ul>
<li>
<p>You may no longer need to change a mutable variable after a certain point, and if your code is sufficiently complex you might want the compiler to guarantee this for you:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn spot_ate_my_slippers() -&gt; bool {
</span><span class="boring">    false
</span><span class="boring">}
</span><span class="boring">fn feed(_: &amp;str) {}
</span>let mut good_boy = &quot;Spot&quot;;
if spot_ate_my_slippers() {
    good_boy = &quot;Rover&quot;;
}
let good_boy = good_boy; // never going to change my dog again, who's a good boy
feed(&amp;good_boy);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Another common pattern is to retain the same variable name as you gradually unwrap things to a simpler type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let url = &quot;http://foo.com:1234&quot;;
</span>let port_number = url.split(&quot;:&quot;).skip(2).next().unwrap();
    // hmm, maybe somebody else already wrote a better URL parser....? naah, probably not
let port_number = port_number.parse::&lt;u16&gt;().unwrap();
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h2 id="how-can-i-avoid-the-performance-penalty-of-unwrap"><a class="header" href="#how-can-i-avoid-the-performance-penalty-of-unwrap">How can I avoid the performance penalty of <code>unwrap()</code>?</a></h2>
<p>C++ has no equivalent to Rust's <code>match</code>, so programmers coming from C++ often underuse it.</p>
<p>A heuristic: if you find yourself <code>unwrap()</code>ing, <em>especially</em> in an <code>if</code>/<code>else</code> statement, you should restructure your code to use a more sophisticated <code>match</code>.</p>
<p>For example, note the <code>unwrap()</code> in here (implying some runtime branch):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_parse() -&gt; Result&lt;u64,std::num::ParseIntError&gt; {
</span><span class="boring">let s = &quot;0x64a&quot;;
</span>if s.starts_with(&quot;0x&quot;) {
    u64::from_str_radix(s.strip_prefix(&quot;0x&quot;).unwrap(), 16)
} else {
    s.parse::&lt;u64&gt;()
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>and no extra <code>unwrap()</code> here:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_parse() -&gt; Result&lt;u64,std::num::ParseIntError&gt; {
</span><span class="boring">let s = &quot;0x64a&quot;;
</span>match s.strip_prefix(&quot;0x&quot;) {
    None =&gt; s.parse::&lt;u64&gt;(),
    Some(remainder) =&gt; u64::from_str_radix(remainder, 16),
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> and <code>matches!</code> are just as good as <code>match</code> but sometimes a little more concise. <code>cargo clippy</code> will usually tell you if you're using a <code>match</code> which can be simplified to one of those other two constructions.</p>
<h2 id="how-do-i-access-variables-from-within-a-spawned-thread"><a class="header" href="#how-do-i-access-variables-from-within-a-spawned-thread">How do I access variables from within a spawned thread?</a></h2>
<p>Use <a href="https://doc.rust-lang.org/nightly/std/thread/fn.scope.html"><code>std::thread::scope</code></a>.</p>
<h2 id="when-should-i-use-runtime-checks-vs-jumping-through-hoops-to-do-static-checks"><a class="header" href="#when-should-i-use-runtime-checks-vs-jumping-through-hoops-to-do-static-checks">When should I use runtime checks vs jumping through hoops to do static checks?</a></h2>
<p>Everyone learns Rust a different way, but it's said that some people reach a
point of &quot;trait mania&quot; where they try to encode <em>too much</em> via the type
system, and get in a mess. So, in learning Rust, you will want to strike a
balance between runtime checks (easy) or static compile-time checks (more
efficient but requires deeper understanding.)</p>
<blockquote>
<p>It’s very personal - some people learn better if they opt out of
language features, others not. - MG</p>
</blockquote>
<p>Some heuristics for how to keep things simple during the beginning of your
Rust journey:</p>
<ul>
<li>It's OK to start with lots of <code>.unwrap()</code>, cloning and <code>Arc</code>/<code>Rc</code>.</li>
<li>Start to use more advanced language features when you feel annoyed with
the amount of boilerplate. (As an expert, you'll switch to a different
strategy which is to consider the virality of your choices through the
codebase.)</li>
<li>Don't use traits until you have to. You might (for instance) need to use
a trait to make some code unit testable, but overoptimizing for that too
soon is a mistake. Some say that it's wise initially to avoid defining
any new traits at all.</li>
<li>Try to keep types smaller.</li>
</ul>
<p>Specifically on reference counting,</p>
<blockquote>
<p>If using Rc means you can avoid a lifetime parameter which is in half the
APIs in the project, that’s a very reasonable choice. If it avoids a single
lifetime somewhere, probably not a good idea. But measure before deciding. - MG</p>
</blockquote>
<p>If you want to bail out of the complexity of static checks, which runtime checks
are OK?</p>
<ul>
<li><code>unwrap()</code> and <code>Option</code> is mostly fine.</li>
<li><code>Arc</code> and <code>Rc</code> is also fine in most cases.</li>
<li>Extensive use of <code>clone()</code> is fine but will have a performance impact.</li>
<li><code>Cell</code> is regarded as a code smell and suggests you don't understand your
lifetimes - it should be used sparingly.</li>
<li><code>unsafe</code> is definitely not OK. It's harder to write <code>unsafe</code> Rust than to write
C or C++, because Rust has additional aliasing rules. If you're reaching for
<code>unsafe</code> to work around the complexity of Rust's static type system, as a
relative Rust beginner, please reconsider and look into the other options
listed above.</li>
</ul>
<p>Doing lifetime magic — where &quot;magic&quot; means annotating a function or complex
type with more than 1 lifetime, or other wizardry — is often an optimization
that you can defer until later. In the beginning, and when writing small
programs that you only intend to use a few times ('scripts'), copying is fine.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="signatures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="signatures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="third_party/mermaid/mermaid.min.js"></script>
                <script type="text/javascript" src="third_party/mermaid/mermaid-init.js"></script>
        
        
    </body>
</html>
