<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cppfaq.rs</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="code.html"><strong aria-hidden="true">2.</strong> Questions about code in function bodies</a></li><li class="chapter-item expanded "><a href="signatures.html"><strong aria-hidden="true">3.</strong> Questions about your function signatures</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">4.</strong> Questions about your types</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Questions about your APIs</div></li><li class="chapter-item expanded "><a href="codebase.html"><strong aria-hidden="true">6.</strong> Questions about your whole codebase</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Questions about your processes</div></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">cppfaq.rs</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/google/rust-design-faq" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>So, you're coming from C++ and want to write Rust? Great!</p>
<p>You have questions? We have answers.</p>
<p>This book is a collection of frequently asked questions for those arriving from existing C++ codebases. It guides you on how to adapt your C++ thinking to the new facilities available in Rust. It should help you if you're coming from other object-oriented languages such as Java too.</p>
<p>Although it's structured as questions and answers, it can also be read front-to-back, to give you hints about how to adapt your C++/Java thinking to a more idiomatically Rusty approach.</p>
<p>It does not aim to teach you Rust - there are <a href="https://www.rust-lang.org/learn">many better resources</a>. It doesn't aim to talk about Rust idioms <em>in general</em> - <a href="https://rust-unofficial.github.io/patterns/idioms/index.html">there are great existing guides for that</a>. This guide is specifically about transitioning from some other traditionally OO language. If you're coming from such a language, you'll have questions about how to achieve the same outcomes in idiomatic Rust. That's what this guide is for.</p>
<h1 id="structure"><a class="header" href="#structure">Structure</a></h1>
<p>The guide starts with idioms at the small scale - answering questions about how you'd write a few lines of code - and moves towards ever larger patterns - answering questions about how you'd structure your whole codebase.</p>
<h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>The following awesome people helped write the answers here, and they're sometimes quoted using the abbreviations given.</p>
<p>Thanks to Alyssa Haroldsen <a href="https://twitter.com/kupiakos">(@kupiakos)</a> (AH), Augie Fackler (AF), David Tolnay <a href="https://twitter.com/davidtolnay">(@davidtolnay)</a> (DT), Łukasz Anforowicz (LA), Manish Goregaokar <a href="https://twitter.com/ManishEarth">(@ManishEarth)</a> (MG), Mike Forster (MF), Miguel Young de la Sota <a href="https://twitter.com/DrawsMiguel">(@DrawsMiguel)</a> (MY), and Tyler Mandry <a href="https://twitter.com/tmandry">(@tmandry)</a> (TM).</p>
<p>Their views have been edited and collated by Adrian Taylor <a href="https://twitter.com/adehohum">(@adehohum)</a>, <a href="mailto:danakj@chromium.org">danakj@chromium.org</a> and Martin Brænne. Any errors or misrepresentations are ours.</p>
<p>Licensed under either of Apache License, Version 2.0 or MIT license at your option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-code-in-function-bodies"><a class="header" href="#questions-about-code-in-function-bodies">Questions about code in function bodies</a></h1>
<h2 id="how-can-i-avoid-the-performance-penalty-of-bounds-checks"><a class="header" href="#how-can-i-avoid-the-performance-penalty-of-bounds-checks">How can I avoid the performance penalty of bounds checks?</a></h2>
<p>Rust array and list accesses are all bounds checked. You may be worried about a performance penalty. How can you avoid that?</p>
<blockquote>
<p>Contort yourself a little bit to use iterators. - MY</p>
</blockquote>
<p>Rust gives you choices around functional versus imperative style, but things often work better in a functional style. Specifically - if you've got something iterable, then there are probably functional methods to do what you want.</p>
<p>For instance, suppose you need to work out what food to get at the petshop. Here's code that does this in an imperative style:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_a() -&gt; HashSet&lt;&amp;'static str&gt; {
    let mut meals_needed = HashSet::new();
    for n in 0..PETS.len() { // ugh
        if PETS[n].is_hungry {
            meals_needed.insert(PETS[n].meal_needed);
        }
    }
    meals_needed
}
<span class="boring">}
</span></code></pre></pre>
<p>The loop index is verbose and error-prone. Let's get rid of it and loop over an iterator instead:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_b() -&gt; HashSet&lt;&amp;'static str&gt;  {
    let mut meals_needed = HashSet::new();
    for animal in PETS.iter() { // better...
        if animal.is_hungry {
            meals_needed.insert(animal.meal_needed);
        }
    }
    meals_needed
}
<span class="boring">}
</span></code></pre></pre>
<p>We're accessing the loop through an iterator, but we're still processing the elements inside a loop. It's often more idiomatic to replace the loop with a chain of iterators:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_c() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect() // best...
}
<span class="boring">}
</span></code></pre></pre>
<p>The obvious advantage of the third approach is that it's more concise, but less obviously:</p>
<ul>
<li>The first solution may require Rust to do array bounds checks inside each iteration of the loop, making Rust potentially slower than C++. In this sort of simple example, it likely wouldn't, but functional pipelines simply don't require bounds checks.</li>
<li>The final container (a <code>HashSet</code> in this case) may be able to allocate roughly the right size at the outset, using the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint">size_hint</a> of a Rust iterator.</li>
<li>If you use iterator-style code rather than imperative code, it's more likely the Rust compiler will be able to <a href="https://medium.com/swlh/an-adventure-in-simd-b0e8db4ccca7">auto-vectorize using SIMD instructions</a>.</li>
<li>There is no mutable state within the function. This makes it easier to verify that the code is correct and to avoid introducing bugs when changing it. In this simple example it may be obvious that calling the <code>HashSet::insert</code> is the only mutation to the set, but in more complex scenarios it is quite easy to lose the overview.</li>
<li>And as a new arrival from C++, you may find this hard to believe: For an experienced Rustacean it'll be more readable.</li>
</ul>
<p>Here are some more iterator techniques to help avoid materializing a collection:</p>
<ul>
<li>
<p>You can <a href="https://doc.rust-lang.org/std/iter/struct.Chain.html">chain two iterators together</a> to make a longer one.</p>
</li>
<li>
<p>If you need to iterate two lists, <a href="https://doc.rust-lang.org/std/iter/struct.Zip.html">zip them together</a> to avoid bounds checks on either.</p>
</li>
<li>
<p>If you want to feed all your animals, and also feed a nearby duck, just chain the iterator to <code>std::iter::once</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">static PETS: [Animal; 0] = [];
</span><span class="boring"> static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">        kind: &quot;Duck&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;pondweed&quot;,
</span><span class="boring">    };
</span>fn make_shopping_list_d() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .chain(std::iter::once(&amp;NEARBY_DUCK))
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>(Similarly, if you want to add one more item to the shopping list - maybe you're hungry, as well as your menagerie? - just add it after the <code>map</code>).</p>
</li>
<li>
<p><code>Option</code> is iterable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">static PETS: [Animal; 0] = [];
</span><span class="boring">struct Pond;
</span><span class="boring">static MY_POND: Pond = Pond;
</span>fn pond_inhabitant(pond: &amp;Pond) -&gt; Option&lt;&amp;Animal&gt; {
    // ...
<span class="boring">   None
</span>}

fn make_shopping_list_e() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .chain(pond_inhabitant(&amp;MY_POND))
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>Here's a diagram showing how data flows in this iterator pipeline:</p>
</li>
</ul>
<pre class="mermaid">  flowchart LR
    %%{ init: { 'flowchart': { 'nodeSpacing': 40, 'rankSpacing': 15 } } }%%
      Pets
      Filter([filter by hunger])
      Map([map to noms])
      Meals
      uniqueify([uniqueify])
      shopping[Shopping list]
      Pets ---&gt; Filter
      Pond
      Pond ---&gt; inhabitant
      inhabitant[Optional pond inhabitant]
      inhabitant ---&gt; Map
      Filter ---&gt; Map
      Map ---&gt; Meals
      Meals ---&gt; uniqueify
      uniqueify ---&gt; shopping
  </pre>
<ul>
<li>Here are other iterator APIs that will come in useful:
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned">cloned</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten">flatten</a></li>
</ul>
</li>
</ul>
<p>C++20 recently introduced <a href="https://en.cppreference.com/w/cpp/ranges">ranges</a>, a feature that allows you to pipeline operations on a collection similar to the way Rust iterators do, so this style of programming is likely to become more common in C++ too.</p>
<p>To summarize: While in C++ you tend to operate on collections by performing a series of operations on each individual item, in Rust you'll typically apply a pipeline of operations to the whole collection. Make this mental switch and your code will not just become more idiomatic but more efficient, too.</p>
<h2 id="isnt-it-confusing-to-use-the-same-variable-name-twice"><a class="header" href="#isnt-it-confusing-to-use-the-same-variable-name-twice">Isn't it confusing to use the same variable name twice?</a></h2>
<p>In Rust, it's common to reuse the same name for multiple variables in a function. For a C++ programmer, this is weird, but there are two good reasons to do it:</p>
<ul>
<li>
<p>You may no longer need to change a mutable variable after a certain point, and if your code is sufficiently complex you might want the compiler to guarantee this for you:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn spot_ate_my_slippers() -&gt; bool {
</span><span class="boring">    false
</span><span class="boring">}
</span><span class="boring">fn feed(_: &amp;str) {}
</span>let mut good_boy = &quot;Spot&quot;;
if spot_ate_my_slippers() {
    good_boy = &quot;Rover&quot;;
}
let good_boy = good_boy; // never going to change my dog again, who's a good boy
feed(&amp;good_boy);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Another common pattern is to retain the same variable name as you gradually unwrap things to a simpler type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let url = &quot;http://foo.com:1234&quot;;
</span>let port_number = url.split(&quot;:&quot;).skip(2).next().unwrap();
    // hmm, maybe somebody else already wrote a better URL parser....? naah, probably not
let port_number = port_number.parse::&lt;u16&gt;().unwrap();
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h2 id="how-can-i-avoid-the-performance-penalty-of-unwrap"><a class="header" href="#how-can-i-avoid-the-performance-penalty-of-unwrap">How can I avoid the performance penalty of <code>unwrap()</code>?</a></h2>
<p>C++ has no equivalent to Rust's <code>match</code>, so programmers coming from C++ often underuse it.</p>
<p>A heuristic: if you find yourself <code>unwrap()</code>ing, <em>especially</em> in an <code>if</code>/<code>else</code> statement, you should restructure your code to use a more sophisticated <code>match</code>.</p>
<p>For example, note the <code>unwrap()</code> in here (implying some runtime branch):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_parse() -&gt; Result&lt;u64,std::num::ParseIntError&gt; {
</span><span class="boring">let s = &quot;0x64a&quot;;
</span>if s.starts_with(&quot;0x&quot;) {
    u64::from_str_radix(s.strip_prefix(&quot;0x&quot;).unwrap(), 16)
} else {
    s.parse::&lt;u64&gt;()
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>and no extra <code>unwrap()</code> here:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_parse() -&gt; Result&lt;u64,std::num::ParseIntError&gt; {
</span><span class="boring">let s = &quot;0x64a&quot;;
</span>match s.strip_prefix(&quot;0x&quot;) {
    None =&gt; s.parse::&lt;u64&gt;(),
    Some(remainder) =&gt; u64::from_str_radix(remainder, 16),
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> and <code>matches!</code> are just as good as <code>match</code> but sometimes a little more concise. <code>cargo clippy</code> will usually tell you if you're using a <code>match</code> which can be simplified to one of those other two constructions.</p>
<h2 id="how-do-i-access-variables-from-within-a-spawned-thread"><a class="header" href="#how-do-i-access-variables-from-within-a-spawned-thread">How do I access variables from within a spawned thread?</a></h2>
<p>Use <a href="https://docs.rs/crossbeam/0.8.1/crossbeam/thread/struct.Scope.html#method.spawn"><code>crossbeam_utils::thread::scope</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-your-function-signatures"><a class="header" href="#questions-about-your-function-signatures">Questions about your function signatures</a></h1>
<h2 id="should-i-return-an-iterator-or-a-collection"><a class="header" href="#should-i-return-an-iterator-or-a-collection">Should I return an iterator or a collection?</a></h2>
<blockquote>
<p>Pretty much always return an iterator. - AH</p>
</blockquote>
<p>We suggested you <a href="./code.html#how-can-i-avoid-the-performance-penalty-of-bounds-checks">use iterators a lot in your code</a>. Share the love! Give iterators to your callers too.</p>
<p>If you <em>know</em> your caller will store the items you're returning in a concrete collection, such as a <code>Vec</code> or a <code>HashSet</code>, you may want to return that. In all other cases, return an iterator.</p>
<p>Your caller might:</p>
<ul>
<li>Collect the iterator into a <code>Vec</code></li>
<li>Collect it into a <code>HashSet</code> or some other specialized container</li>
<li>Loop over the items</li>
<li>Filter them or otherwise completely ignore some</li>
</ul>
<p>Collecting the items into vector will only turn out to be right in one of these cases. In the other cases, you're wasting memory and CPU time by building a concrete collection.</p>
<p>This is weird for C++ programmers because iterators don't usually have robust references into the underlying data. Even Java iterators are scary, throwing <code>ConcurrentModificationExceptions</code> when you least expect it. Rust prevents that, at compile time. If you <em>can</em> return an iterator, you should.</p>
<pre class="mermaid">flowchart LR
    subgraph Caller
    it_ref[reference to iterator]
    end
    subgraph it_outer[Iterator]
    it[Iterator]
    it_ref --reference--&gt; it
    end
    subgraph data[Underlying data]
    dat[Underlying data]
    it --reference--&gt; dat
    end
</pre>
<h2 id="how-flexible-should-my-parameters-be"><a class="header" href="#how-flexible-should-my-parameters-be">How flexible should my parameters be?</a></h2>
<p>Which of these is best?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn a(params: &amp;[String]) {
    // ...
}

fn b(params: &amp;[&amp;str]) {
    // ...
}

fn c(params: &amp;[impl AsRef&lt;str&gt;]) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>(You'll need to make an equivalent decision in other cases, e.g. <code>Path</code> versus <code>PathBuf</code> versus <code>AsRef&lt;Path&gt;</code>.)</p>
<p>None of the options is clearly superior; for each option, there's a case it can't handle that the others can:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn a(params: &amp;[String]) {
</span><span class="boring">}
</span><span class="boring">fn b(params: &amp;[&amp;str]) {
</span><span class="boring">}
</span><span class="boring">fn c(params: &amp;[impl AsRef&lt;str&gt;]) {
</span><span class="boring">}
</span>fn main() {
    a(&amp;[]);
    // a(&amp;[&quot;hi&quot;]); // doesn't work
    a(&amp;vec![format!(&quot;hello&quot;)]);

    b(&amp;[]);
    b(&amp;[&quot;hi&quot;]);
    // b(&amp;vec![format!(&quot;hello&quot;)]); // doesn't work

    // c(&amp;[]); // doesn't work
    c(&amp;[&quot;hi&quot;]);
    c(&amp;vec![format!(&quot;hello&quot;)]);
}
</code></pre></pre>
<p>So you have a variety of interesting ways to <em>slightly</em> annoy your callers under different circumstances. Which is best?</p>
<p><code>AsRef</code> has some advantages: if a caller has a <code>Vec&lt;String&gt;</code>, they can use that directly, which would be impossible with the other options. But if they want to pass an empty list, they'll have to explicitly specify the type (for instance <code>&amp;Vec::&lt;String&gt;::new()</code>).</p>
<blockquote>
<p>Not a huge fan of AsRef everywhere - it's just saving the caller typing. If you have lots of AsRef then nothing is object-safe. - MG</p>
</blockquote>
<p>TL;DR: choose the middle option, <code>&amp;[&amp;str]</code>. If your caller happens to have a vector of <code>String</code>, it's relatively little work to get a slice of <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn b(params: &amp;[&amp;str]) {
</span><span class="boring">}
</span>
fn main() {
    // Instead of b(&amp;vec![format!(&quot;hello&quot;)]);
    let hellos = vec![format!(&quot;hello&quot;)];
    b(&amp;hellos.iter().map(String::as_str).collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<h2 id="how-do-i-overload-constructors"><a class="header" href="#how-do-i-overload-constructors">How do I overload constructors?</a></h2>
<p>You can't do this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct BirthdayCard {}
</span>impl BirthdayCard {
    fn new(name: &amp;str) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }

    // Can't add more overloads:
    //
    // fn new(name: &amp;str, age: i32) -&gt; BirthdayCard { ... }
    //
    // fn new(name: &amp;str, text: &amp;str) -&gt; BirthdayCard { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have a default constructor, and a few variants for other cases, you can simply write them as different static methods. An idiomatic way to do this is to write a <code>new()</code> constructor and then <code>with_foo()</code> constructors that apply the given &quot;foo&quot; when constructing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Racoon {}
</span>impl Racoon {
    fn new() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
    fn with_age(age: usize) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have have a bunch of constructors and no default, it may make sense to instead provide a set of <code>new_foo()</code> constructors.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Animal {}
</span>impl Animal {
    fn new_squirrel() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
    fn new_badger() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For a more complex situation, you may use <a href="https://rust-lang.github.io/api-guidelines/type-safety.html#builders-enable-construction-of-complex-values-c-builder">the builder pattern</a>. The builder has a set of methods which take <code>&amp;mut self</code> and return <code>&amp;mut Self</code>. Then add a <code>build()</code> that returns the final constructed object.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BirthdayCard {}

struct BirthdayCardBuilder {}
impl BirthdayCardBuilder {
    fn new(name: &amp;str) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }

    fn age(&amp;mut self, age: i32) -&gt; &amp;mut Self {
<span class="boring">        self
</span>        // ...
    }

    fn text(&amp;mut self, text: &amp;str) -&gt; &amp;mut Self {
<span class="boring">        self
</span>        // ...
    }

    fn build(&amp;mut self) -&gt; BirthdayCard { BirthdayCard { /* ... */ } }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can then <a href="https://rust-lang.github.io/api-guidelines/type-safety.html#non-consuming-builders-preferred">chain these</a> into short or long constructions, passing parameters as necessary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct BirthdayCard {}
</span><span class="boring">
</span><span class="boring">struct BirthdayCardBuilder {}
</span><span class="boring">impl BirthdayCardBuilder {
</span><span class="boring">    fn new(name: &amp;str) -&gt; BirthdayCardBuilder {
</span><span class="boring">      Self{}
</span><span class="boring">      // ...
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn age(&amp;mut self, age: i32) -&gt; &amp;mut BirthdayCardBuilder {
</span><span class="boring">        self
</span><span class="boring">        // ...
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn text(&amp;mut self, text: &amp;str) -&gt; &amp;mut BirthdayCardBuilder {
</span><span class="boring">        self
</span><span class="boring">        // ...
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn build(&amp;mut self) -&gt; BirthdayCard { BirthdayCard { /* ... */ } }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let card = BirthdayCardBuilder::new(&quot;Paul&quot;)
        .age(64)
        .text(&quot;Happy Valentine's Day!&quot;)
        .build();
}
</code></pre></pre>
<p>Note another advantage of builders: Overloaded constructors often don't provide all possible combinations of parameters, whereas with the builder pattern, you can combine exactly the parameters you want.</p>
<h2 id="when-must-i-use-must_use"><a class="header" href="#when-must-i-use-must_use">When must I use <code>#[must_use]</code>?</a></h2>
<blockquote>
<p>Use it on Results and mutex locks. - MG</p>
</blockquote>
<p><code>#[must_use]</code> causes a compile error if the caller ignores the return value.</p>
<p>Rust functions are often single-purpose. They either:</p>
<ul>
<li>Return a value without any side effects; or</li>
<li>Do something (i.e. have side effects) and return nothing.</li>
</ul>
<p>In neither case do you need to think about <code>#[must_use]</code>. (In the first case,
nobody would call your function unless they were going to use the result.)</p>
<p><code>#[must_use]</code> is useful for those rarer functions which return a result <em>and</em>
have side effects. In most such cases, it's wise to specify <code>#[must_use]</code>, unless
the return value is truly optional (for example in
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert"><code>HashMap::insert</code></a>).</p>
<h2 id="when-should-i-take-parameters-by-value"><a class="header" href="#when-should-i-take-parameters-by-value">When should I take parameters by value?</a></h2>
<p>Move semantics are more common in Rust than in C++.</p>
<blockquote>
<p>In C++ moves tend to be an optimization, whereas in Rust they're a key semantic part of the program. - MY</p>
</blockquote>
<p>To a first approximation, you should assume similar performance when passing
things by (moved) value or by reference. It's true that a move may turn out to
be a <code>memcpy</code>, but it's often optimized away.</p>
<blockquote>
<p>Express the ownership relationship in the type system, instead of trying to second-guess the compiler for efficiency. - AF</p>
</blockquote>
<p>The moves are, of course, destructive - and unlike in C++, the compiler
enforces that you don't reuse a variable that has been moved.
Some C++ objects become toxic after they've moved; that's not a
risk in Rust.</p>
<p>So here's the heuristic: if a caller shouldn't be able to use an object again,
pass it via move semantics in order to consume it.</p>
<p>An extreme example: a UUID is supposed to be globally unique - it might cause a
logic error for a caller to retain knowledge of a UUID after passing it to a callee.</p>
<p>More generally, consume data enthusiastically to avoid logical errors during future
refactorings. For instance, if some command-line options are overridden by a
runtime choice, consume those old options - then any future refactoring which
uses them after that point will give you a compile error. This pattern is
surprisingly effective at spotting errors in your assumptions.</p>
<h2 id="should-i-ever-take-self-by-value"><a class="header" href="#should-i-ever-take-self-by-value">Should I ever take <code>self</code> by value?</a></h2>
<p>Sometimes. If you've got a member function which destroys or transforms a thing,
it should take <code>self</code> by value. Examples:</p>
<ul>
<li>Closing a file and returning a result code.</li>
<li>A builder-pattern object which spits out the thing it was building. (<a href="https://docs.rs/bindgen/0.59.0/bindgen/struct.Builder.html#method.generate">Example</a>).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-your-types"><a class="header" href="#questions-about-your-types">Questions about your types</a></h1>
<h2 id="my-class-needs-mutable-references-to-other-things-to-do-its-job-other-classes-need-mutable-references-to-these-things-too-what-do-i-do"><a class="header" href="#my-class-needs-mutable-references-to-other-things-to-do-its-job-other-classes-need-mutable-references-to-these-things-too-what-do-i-do">My 'class' needs mutable references to other things to do its job. Other classes need mutable references to these things too. What do I do?</a></h2>
<p>It's common in C++ to have a class that contain mutable references to other
objects; the class mutates those objects to do its work. Often, there
are several classes that all hold a mutable reference to the same object. Here
is a diagram that illustrates this:</p>
<pre class="mermaid">flowchart LR
    subgraph Shared functionality
    important[Important Shared Object]
    end
    subgraph ObjectA
    methodA[Method]
    refa[Mutable Reference]--&gt;important
    methodA-. Acts on shared object.-&gt;important
    end
    subgraph ObjectB
    refb[Mutable Reference]--&gt;important
    methodB[Method]
    methodB-. Acts on shared object.-&gt;important
    end
    main --&gt; ObjectA
    main --&gt; ObjectB
    main-. Calls .-&gt; methodA
    main-. Calls .-&gt; methodB
</pre>
<p>In Rust, you can't have multiple mutable references to a shared object, so what
do you do?</p>
<p>First of all, consider moving behavior out of your types. (See
<a href="./codebase.html#the-c-observer-pattern-is-hard-in-rust-what-to-do">the answer about the observer pattern</a> and especially
<a href="./codebase.html#option-2-drive-the-objects-from-the-code-not-the-other-way-round">the second option described there</a>.)</p>
<p>Even in Rust, though, it's still often the best choice to make complex behavior
part of the type within <code>impl</code> blocks. You can still do that - but don't
<em>store</em> references. Instead, pass them into each function call.</p>
<pre class="mermaid">flowchart LR
    subgraph Shared functionality
    important[Important Shared Object]
    end
    subgraph ObjectA
    methodA[Method]
    methodA-. Acts on shared object.-&gt;important
    end
    subgraph ObjectB
    methodB[Method]
    methodB-. Acts on shared object.-&gt;important
    end
    main --&gt; ObjectA
    main --&gt; ObjectB
    main --&gt; important
    main-. Passes reference to shared object.-&gt; methodA
    main-. Passes reference to shared object.-&gt; methodB
</pre>
<p>Instead of this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantSharedObject;
</span><span class="boring">struct ObjectA&lt;'a&gt; {
</span><span class="boring">   important_shared_object: &amp;'a mut ImportantSharedObject,
</span><span class="boring">}
</span><span class="boring">impl&lt;'a&gt; ObjectA&lt;'a&gt; {
</span><span class="boring">   fn new(important_shared_object: &amp;'a mut ImportantSharedObject) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           important_shared_object
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">   fn do_something(&amp;mut self) {
</span><span class="boring">       // act on self.important_shared_object
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let mut shared_thingy = ImportantSharedObject;
    let mut a = ObjectA::new(&amp;mut shared_thingy);
    a.do_something(); // acts on shared_thingy
}
</code></pre></pre>
<p>Do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantSharedObject;
</span><span class="boring">struct ObjectA;
</span><span class="boring">impl ObjectA {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self
</span><span class="boring">   }
</span><span class="boring">   fn do_something(&amp;mut self, important_shared_object: &amp;mut ImportantSharedObject) {
</span><span class="boring">       // act on important_shared_object
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let mut shared_thingy = ImportantSharedObject;
    let mut a = ObjectA::new();
    a.do_something(&amp;mut shared_thingy); // acts on shared_thingy
}
</code></pre></pre>
<p>(Happily this also gets rid of named lifetime parameters.)</p>
<p>If you have a hundred such shared objects, you probably don't want a
hundred function parameters. So it's usual to bundle them up into
a context structure which can be passed into each function call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantSharedObject;
</span><span class="boring">struct AnotherImportantObject;
</span>struct Ctx&lt;'a&gt; {
    important_shared_object: &amp;'a mut ImportantSharedObject,
    another_important_object: &amp;'a mut AnotherImportantObject,
}

<span class="boring">struct ObjectA;
</span><span class="boring">impl ObjectA {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self
</span><span class="boring">   }
</span><span class="boring">   fn do_something(&amp;mut self, ctx: &amp;mut Ctx) {
</span><span class="boring">       // act on ctx.important_shared_object and ctx.another_important_thing
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let mut shared_thingy = ImportantSharedObject;
    let mut another_thingy = AnotherImportantObject;
    let mut ctx = Ctx {
        important_shared_object: &amp;mut shared_thingy,
        another_important_object: &amp;mut another_thingy,
    };
    let mut a = ObjectA::new();
    a.do_something(&amp;mut ctx); // acts on both the shared thingies
}
</code></pre></pre>
<pre class="mermaid">flowchart LR
    subgraph Shared functionality
    important[Important Shared Object]
    end
    subgraph Context
    refa[Mutable Reference]--&gt;important
    end
    subgraph ObjectA
    objectA[Object A]
    methodA[Method]
    methodA-. Acts on shared object.-&gt;important
    end
    subgraph ObjectB
    objectB[Object B]
    methodB[Method]
    methodB-. Acts on shared object.-&gt;important
    end
    main --&gt; objectA
    main --&gt; objectB
    main --&gt; Context
    main-. Passes context.-&gt; methodA
    main-. Passes context.-&gt; methodB
</pre>
<p>Even simpler: just put all the data directly into <code>Ctx</code>. But the key point
is that this context object is passed around into just about all function calls
rather than being stored anywhere, thus negating any borrowing/lifetime concerns.</p>
<p>This pattern can be seen in <a href="https://github.com/rust-lang/rust-bindgen/blob/271eeb0782d34942267ceabcf5f1cf118f0f5842/src/ir/context.rs#L308">bindgen</a>,
for example.</p>
<blockquote>
<p>Split out borrowing concerns from the object concerns. - MG</p>
</blockquote>
<p>To generalize this idea, try to avoid storing references to anything that might
need to be changed. Instead take those things as parameters. For instance
<code>petgraph</code> <a href="https://docs.rs/petgraph/0.6.0/petgraph/visit/trait.Walker.html">takes the entire graph as context to a <code>Walker</code> object</a>,
such that the graph can be changed while you're walking it.</p>
<h2 id="my-type-needs-to-store-arbitrary-user-data-what-do-i-do-instead-of-void-"><a class="header" href="#my-type-needs-to-store-arbitrary-user-data-what-do-i-do-instead-of-void-">My type needs to store arbitrary user data. What do I do instead of <code>void *</code>?</a></h2>
<p>Ideally, your type would know all possible types of user data that it could store.
You'd represent this as an <code>enum</code> with variant data for each possibility. This
would give complete compile-time type safety.</p>
<p>But sometimes code needs to store data for which it can't depend upon
the definition: perhaps it's defined by a totally different area of the
codebase, or belongs to clients. Such possibilities can't be enumerated in
advance. Until recently, the only real option in C++ was to use a <code>void *</code>
and have clients downcast to get their original type back. Modern C++ offers
a much better option, <code>std::any</code>; if you've come across that, Rust's equivalent
will seem very familiar.</p>
<p>In Rust, the <a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>Any</code></a> type
allows you to store <em>anything</em> and retrieve it later in a type-safe fashion:</p>
<pre><pre class="playground"><code class="language-rust">use std::any::Any;

struct MyTypeOfUserData(u8);

fn main() {
  let any_user_data: Box&lt;dyn Any&gt; = Box::new(MyTypeOfUserData(42));
  let stored_value = any_user_data.downcast_ref::&lt;MyTypeOfUserData&gt;().unwrap().0;
  println!(&quot;{}&quot;, stored_value);
}
</code></pre></pre>
<p>If you want to be more prescriptive about what can be stored, you can define
a trait (let's call it <code>UserData</code>) and store a <code>Box&lt;dyn UserData&gt;</code>.
Your trait should have a method <code>fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any;</code>
Each implementation can just return <code>self</code>.</p>
<p>Your caller can then do this:</p>
<pre><pre class="playground"><code class="language-rust">trait UserData {
  fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any;
  // ...other trait methods which you wish to apply to any UserData...
}

struct MyTypeOfUserData(u8);

impl UserData for MyTypeOfUserData {
  fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any { self }
}

fn main() {
  // Store a generic Box&lt;dyn UserData&gt;
  let user_data: Box&lt;dyn UserData&gt; = Box::new(MyTypeOfUserData(42));
  // Get back to a specific type
  let stored_value = user_data.as_any().downcast_ref::&lt;MyTypeOfUserData&gt;().unwrap().0;
  println!(&quot;{}&quot;, stored_value);
}
</code></pre></pre>
<p>Of course, enumerating all possible stored variants remains preferable such that the
compiler helps you to avoid runtime panics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-your-whole-codebase"><a class="header" href="#questions-about-your-whole-codebase">Questions about your whole codebase</a></h1>
<h2 id="the-c-observer-pattern-is-hard-in-rust-what-to-do"><a class="header" href="#the-c-observer-pattern-is-hard-in-rust-what-to-do">The C++ observer pattern is hard in Rust. What to do?</a></h2>
<p>The C++ observer pattern usually means that there are broadcasters sending messages to consumers:</p>
<pre class="mermaid">flowchart TB
    broadcaster_a[Broadcaster A]
    broadcaster_b[Broadcaster B]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    consumer_c[Consumer C]
    broadcaster_a --&gt; consumer_a
    broadcaster_b --&gt; consumer_a
    broadcaster_a --&gt; consumer_b
    broadcaster_b --&gt; consumer_b
    broadcaster_a --&gt; consumer_c
    broadcaster_b --&gt; consumer_c
</pre>
<p>The broadcasters maintain lists of consumers, and the consumers act in response to messages (often mutating their own state.)</p>
<p>This doesn't work in Rust, because it requires the broadcasters to hold mutable references to the consumers.</p>
<p>What do you do?</p>
<h3 id="option-1-make-everything-runtime-checked"><a class="header" href="#option-1-make-everything-runtime-checked">Option 1: make everything runtime-checked</a></h3>
<p>Each of your consumers could become an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> or, if you need thread-safety, an <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>.</p>
<p>The <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> allows broadcasters to share ownership of a consumer. The <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a> allows each broadcaster to acquire a mutable reference to a consumer when it needs to send a message.</p>
<p>This example shows how, in Rust, you <a href="https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">may independently choose reference counting <em>or</em> interior mutability</a>. In this case we need both.</p>
<p>Just like typical reference counting in C++, <code>Rc</code> and <code>Arc</code> have the option to provide a weak pointer, so the lifetime of each consumer doesn't need to be extended unnecessarily. As an aside, it would be nice if Rust had an <code>Rc</code>-like type which enforces exactly one owner, and multiple weak ptrs. <code>Rc</code> could be wrapped quite easily to do this.</p>
<p>Reference counting is frowned-upon in C++ because it's expensive. But, in Rust, not so much:</p>
<ul>
<li>Few objects are reference counted; the majority of objects are owned statically.</li>
<li>Even when objects are reference counted, those counts are rarely incremented and decremented because you can (and do) pass around <code>&amp;Rc&lt;RefCell&lt;T&gt;&gt;</code> most of the time. In C++, the &quot;copy by default&quot; mode means it's much more common to increment and decrement reference counts.</li>
</ul>
<p>In fact, the compile-time guarantees might cause you to do <em>less</em> reference counting than C++:</p>
<blockquote>
<p>In Servo there is a reference count but far fewer objects are reference counted than in the rest of Firefox, because you don’t need to be paranoid - MG</p>
</blockquote>
<p>However: Rust does <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">not prevent reference cycles</a>, although they're only possible if you're using <em>both</em> reference counting and interior mutability.</p>
<h3 id="option-2-drive-the-objects-from-the-code-not-the-other-way-round"><a class="header" href="#option-2-drive-the-objects-from-the-code-not-the-other-way-round">Option 2: drive the objects from the code, not the other way round</a></h3>
<p>In C++, it's common to have all behavior within classes. Those classes <em>are</em> the total behavior of the system, and so they must interact with one another. The observer pattern is common.</p>
<pre class="mermaid">flowchart TB
    broadcaster_a[Broadcaster A]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    broadcaster_a -- observer --&gt; consumer_a
    broadcaster_a -- observer --&gt; consumer_b
</pre>
<p>In Rust, it's more common to have some <em>external</em> function which drives overall behavior.</p>
<pre class="mermaid">flowchart TB
    main(Main)
    broadcaster_a[Broadcaster A]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    main --1--&gt; broadcaster_a
    broadcaster_a --2--&gt; main
    main --3--&gt; consumer_a
    main --4--&gt; consumer_b
</pre>
<p>With this sort of design, it's relatively straightforward to take some output from one object and pass it into another object, with no need for the objects to interact at all.</p>
<p>In the most extreme case, this becomes the <a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity-Component-System architecture</a> used in game design.</p>
<blockquote>
<p>Game developers seem to have completely solved this problem - we can learn from them. - MY</p>
</blockquote>
<h3 id="option-3-use-channels"><a class="header" href="#option-3-use-channels">Option 3: use channels</a></h3>
<p>The observer pattern is a way to decouple large, single-threaded C++ codebases. But if you're trying to decouple a codebase in Rust, perhaps you should assume multi-threading by default? Rust has built-in <a href="https://doc.rust-lang.org/std/sync/mpsc/">channels</a>, and the <a href="https://docs.rs/crossbeam/0.8.0/crossbeam/">crossbeam</a> crate provides multi-producer, multi-consumer channels.</p>
<blockquote>
<p>I'm a Rustacean, we assume massively parallel unless told otherwise :) - MG</p>
</blockquote>
<h2 id="thats-all-very-well-but-i-have-an-existing-c-object-broadcasting-events-how-exactly-should-i-observe-it"><a class="header" href="#thats-all-very-well-but-i-have-an-existing-c-object-broadcasting-events-how-exactly-should-i-observe-it">That's all very well, but I have an existing C++ object broadcasting events. How exactly should I observe it?</a></h2>
<p>If your Rust object is a consumer of events from some pre-existing C++ producer, all the above options remain possible.</p>
<ul>
<li>You can make your object reference counted and have C++ own such a reference (potentially a weak reference)</li>
<li>C++ can deliver the message into a general message bucket. An external function reads messages from that bucket and invokes the Rust object that should handle it. This means the reference counting doesn't need to extend to the Rust objects outside that boundary layer.</li>
<li>You can have a shim object which converts the C++ callback into some message and injects it into a channel-based world.</li>
</ul>
<h2 id="some-of-my-c-objects-have-shared-mutable-state-how-can-i-make-them-safe-in-rust"><a class="header" href="#some-of-my-c-objects-have-shared-mutable-state-how-can-i-make-them-safe-in-rust">Some of my C++ objects have shared mutable state. How can I make them safe in Rust?</a></h2>
<p>You're going to have to do something with <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>: either <code>RefCell&lt;T&gt;</code> or its multithreaded equivalent, <code>RwLock&lt;T&gt;</code>.</p>
<p>You have three decisions to make:</p>
<ol>
<li>Will only Rust code access <em>this particular instance</em> of this object, or might C++ access it too?</li>
<li>If both C++ and Rust may access the object, how do you avoid conflicts?</li>
<li>How should Rust code react if the object is not available, because something else is using it?</li>
</ol>
<p>If only Rust code can use this particular instance of shared state, then simply wrap it in <code>RefCell&lt;T&gt;</code> (single-threaded) or <code>RwLock&lt;T&gt;</code> (multi-threaded). Build a wrapper type such that callers aren't able to access the object directly, but instead only via the lock type.</p>
<p>If C++ also needs to access this particular instance of the shared state, it's more complex. There are presumably some invariants regarding use of this data in C++ - otherwise it would crash all the time. Perhaps the data can be used only from one thread, or perhaps it can only be used with a given mutex held. Your goal is to translate those invariants into an idiomatic Rust API that can be checked (ideally) at compile-time, and (failing that) at runtime.</p>
<p>For example, imagine:</p>
<pre><code class="language-cpp">class SharedMutableGoat {
public:
    void eat_grass(); // mutates tummy state
};

std::mutex lock;
SharedMutableGoat* billy; // only access when owning lock
</code></pre>
<p>Your idiomatic Rust wrapper might be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ffi {
</span><span class="boring">  #[allow(non_camel_case_types)]
</span><span class="boring">  pub struct lock_guard;
</span><span class="boring">  pub fn claim_lock() -&gt; lock_guard { lock_guard{} }
</span><span class="boring">  pub fn eat_grass() {}
</span><span class="boring">  pub fn release_lock(lock: &amp;mut lock_guard) {}
</span><span class="boring">}
</span>struct SharedMutableGoatLock {
    lock: ffi::lock_guard, // owns a std::lock_guard&lt;std::mutex&gt; somehow
};

// Claims the lock, returns a new SharedMutableGoatLock
fn lock_shared_mutable_goat() -&gt; SharedMutableGoatLock {
    SharedMutableGoatLock { lock: ffi::claim_lock() }
}

impl SharedMutableGoatLock {
    fn eat_grass(&amp;mut self) {
        ffi::eat_grass(); // Acts on the global goat
    }
}

impl Drop for SharedMutableGoatLock {
    fn drop(&amp;mut self) {
        ffi::release_lock(&amp;mut self.lock);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Obviously, lots of permutations are possible, but the goal is to ensure that it's simply compile-time impossible to act on the global state unless appropriate preconditions are met.</p>
<p>The final decision is how to react if the object is not available. This decision can apply with C++ mutexes or with Rust locks (for example <code>RwLock&lt;T&gt;</code>). As in C++, the two major options are:</p>
<ul>
<li>Block until the object becomes available.</li>
<li>Try to lock, and if the object is not available, do something else.</li>
</ul>
<p>There can be a third option if you're using async Rust. If the data isn't available, you may be able to return to your event loop using an async version of the lock (<a href="https://docs.rs/tokio/1.5.0/tokio/sync/struct.RwLock.html#method.read">Tokio example</a>, <a href="https://docs.rs/async-std/1.9.0/async_std/sync/struct.RwLock.html">async_std example</a>).</p>
<h2 id="how-do-i-do-a-singleton"><a class="header" href="#how-do-i-do-a-singleton">How do I do a singleton?</a></h2>
<p>Use <a href="https://docs.rs/once_cell/1.7.2/once_cell/">OnceCell</a> for now. <a href="https://doc.rust-lang.org/std/lazy/struct.Lazy.html">This should arrive in the standard library</a> in future.</p>
<h2 id="whats-the-best-way-to-retrofit-rusts-parallelism-benefits-to-an-existing-codebase"><a class="header" href="#whats-the-best-way-to-retrofit-rusts-parallelism-benefits-to-an-existing-codebase">What's the best way to retrofit Rust's parallelism benefits to an existing codebase?</a></h2>
<p>When parallelizing an existing codebase, first check that all existing types are correctly <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>. Generally, though, you should try to avoid implementing these yourself - instead use pre-existing wrapper types which enforce the correct contract (for example, <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>).</p>
<p>After that:</p>
<blockquote>
<p>If you can solve your problem by throwing Rayon at it, do. It’s magic - MG</p>
</blockquote>
<blockquote>
<p>If your task is CPU-bound, Rayon solves this handily. - MY</p>
</blockquote>
<p><a href="https://docs.rs/rayon/1.5.0/rayon/">Rayon</a> offers parallel constructs - for example parallel iterators - which can readily be retrofitted to an existing codebase. It also allows you to create and join tasks. Using Rayon can help <em>simplify</em> your code and eliminate lots of manual scheduling logic.</p>
<p>If your tasks are IO-bound, then you may need to look into async Rust, but that's hard to pull into an existing codebase.</p>
<h2 id="whats-the-best-way-to-architect-a-new-codebase-for-parallelism"><a class="header" href="#whats-the-best-way-to-architect-a-new-codebase-for-parallelism">What's the best way to architect a new codebase for parallelism?</a></h2>
<p>In brief, like in other languages, you have a choice of architectures:</p>
<ul>
<li>Message-passing, using event loops which listen on a channel, receive <code>Send</code> data and pass it on.</li>
<li>More traditional multithreading using <code>Sync</code> data structures such as mutexes (and perhaps Rayon).</li>
</ul>
<blockquote>
<p>There's probably a bias towards message-passing, and that's probably well-informed by its extensibility. - MG</p>
</blockquote>
<h2 id="i-need-a-list-of-nodes-which-can-refer-to-one-another-how"><a class="header" href="#i-need-a-list-of-nodes-which-can-refer-to-one-another-how">I need a list of nodes which can refer to one another. How?</a></h2>
<p>You can't easily do self-referential data structures in Rust. The usual workaround is to <a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/">use an arena</a> and replace references from one node to another with node IDs.</p>
<p>An arena is typically a <code>Vec</code> (or similar), and the node IDs are a newtype wrapper around a simple integer index.</p>
<p>Obviously, Rust doesn't check that your node IDs are valid. If you don't have proper references, what stops you from having stale IDs?</p>
<p>Arenas are often purely additive, which means that you can add entries but not delete them (<a href="https://github.com/Manishearth/elsa/blob/master/examples/mutable_arena.rs">example</a>). If you must have an arena which deletes things, then use generational IDs; see the <a href="https://docs.rs/generational-arena/">generational-arena</a> crate and this <a href="https://www.youtube.com/watch?v=aKLntZcp27M">RustConf keynote</a> for more details.</p>
<p>If arenas still sound like a nasty workaround, consider that you might choose an arena anyway for other reasons:</p>
<ul>
<li>All of the objects in the arena will be freed at the end of the arena's lifetime, instead of during their manipulation, which can give very low latency for some use-cases. <a href="https://docs.rs/bumpalo/3.6.1/bumpalo/">Bumpalo</a> formalizes this.</li>
<li>The rest of your program might have real Rust references into the arena. You can give the arena a named lifetime (<code>'arena</code> for example), making the provenance of those references very clear.</li>
</ul>
<h2 id="im-having-a-miserable-time-making-my-data-structure-should-i-use-unsafe"><a class="header" href="#im-having-a-miserable-time-making-my-data-structure-should-i-use-unsafe">I'm having a miserable time making my data structure. Should I use unsafe?</a></h2>
<p>Low-level data structures are <em>hard</em> in Rust. Arguably, Rust merely makes plain
all the lifetime and ownership issues which you already had in other languages, but
the compiler is brutal about it, and you're going to have a bad day.</p>
<p>Even something as simple as a doubly-linked list is notoriously hard; so much so
that there is a <a href="https://rust-unofficial.github.io/too-many-lists/">book that teaches Rust based solely on linked lists</a>.
As that (wonderful) book makes clear, you are often faced with a choice:</p>
<ul>
<li><a href="https://rust-unofficial.github.io/too-many-lists/fourth.html">Use safe Rust, but shift compile-time checks to runtime</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/fifth.html">Use <code>unsafe</code></a> and
take the same degree of care you'd take in C or C++. And, just like in C or C++,
you'll introduce <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-19029/product_id-48677/Rust-lang-Rust.html">security vulnerabilities in the unsafe code</a>.</li>
</ul>
<p>If you're facing this decision... perhaps there's a third way.</p>
<p>You should almost always be using somebody else's tried-and-tested
data structure.</p>
<p><a href="https://docs.rs/petgraph">petgraph</a> and
<a href="https://docs.rs/slotmap">slotmap</a> are great examples. Use someone else's crate
by default, and resort to writing your own only if you exhaust that option.</p>
<p>C++ makes it hard to pull in third-party dependencies, so it's culturally normal
to write new code. Rust makes it trivial to add dependencies, and so you will
need to do that, even if it feels awkward for a C++ programmer.</p>
<p>This <em>ease</em> of adding dependencies <strong>co-evolved</strong> with the
<em>difficulty</em> of making data structures. It's simply a part of programming in Rust.
You just can't separate the language and the ecosystem.</p>
<p>You might argue that this dependency on third-party crates is concerning
from a supply-chain security point of view. Your author would agree, but
it's just the way you do things in Rust. Stop creating your own data structures.</p>
<h2 id="should-i-have-a-few-big-crates-or-lots-of-small-ones"><a class="header" href="#should-i-have-a-few-big-crates-or-lots-of-small-ones">Should I have a few big crates or lots of small ones?</a></h2>
<p>In the past, it was recommended to have small crates to get optimal build time.
Incremental builds generally make this unnecessary now. You should arrange your
crates optimally for your semantic needs.</p>
<h2 id="what-crates-should-everyone-know-about"><a class="header" href="#what-crates-should-everyone-know-about">What crates should everyone know about?</a></h2>
<table><thead><tr><th align="left">Crate</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><a href="https://docs.rs/rayon/">rayon</a></td><td align="left">parallelizing</td></tr>
<tr><td align="left"><a href="https://docs.rs/serde/">serde</a></td><td align="left">serializing and deserializing</td></tr>
<tr><td align="left"><a href="https://docs.rs/crossbeam/">crossbeam</a></td><td align="left">all sorts of parallelism tools</td></tr>
<tr><td align="left"><a href="https://docs.rs/itertools/">itertools</a></td><td align="left">makes it slightly more pleasant to work with iterators. (For instance, if you want to join an iterator of strings, you can just go ahead and do that, without needing to collect the strings into a <code>Vec</code> first)</td></tr>
<tr><td align="left"><a href="https://docs.rs/petgraph/">petgraph</a></td><td align="left">graph data structures</td></tr>
<tr><td align="left"><a href="https://docs.rs/slotmap/">slotmap</a></td><td align="left">arena-like key-value map</td></tr>
<tr><td align="left"><a href="https://docs.rs/nom/">nom</a></td><td align="left">parsing</td></tr>
<tr><td align="left"><a href="https://docs.rs/clap/">clap</a></td><td align="left">command-line parsing</td></tr>
<tr><td align="left"><a href="https://docs.rs/regex/">regex</a></td><td align="left">err, regular expressions</td></tr>
<tr><td align="left"><a href="https://docs.rs/ring/">ring</a></td><td align="left">the leading crypto library</td></tr>
<tr><td align="left"><a href="https://docs.rs/nalgebra/">nalgebra</a></td><td align="left">linear algebra</td></tr>
<tr><td align="left"><a href="https://docs.rs/once_cell/">once_cell</a></td><td align="left">complex static data</td></tr>
</tbody></table>
<h2 id="how-should-i-call-c-functions-from-rust-and-vice-versa"><a class="header" href="#how-should-i-call-c-functions-from-rust-and-vice-versa">How should I call C++ functions from Rust and vice versa?</a></h2>
<p>Use <a href="https://cxx.rs">cxx</a>.</p>
<p>Oh, you want a justification? In that case, here's the history
which brought us to this point.</p>
<p>From the beginning, Rust supported calling C functions using <a href="https://doc.rust-lang.org/std/keyword.extern.html"><code>extern &quot;C&quot;</code></a>,
<a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a>
and <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[no_mangle]</code></a>.
Such callable C functions had to be declared manually in Rust:</p>
<pre class="mermaid">sequenceDiagram
   Rust--&gt;&gt;extern: unsafe Rust function call
   extern--&gt;&gt;C: call from Rust to C
   participant extern as Rust unsafe extern &quot;C&quot; fn
   participant C as Existing C function
</pre>
<p><a href="https://rust-lang.github.io/rust-bindgen/"><code>bindgen</code></a> was invented
to generate these declarations automatically from existing C/C++ header
files. It has grown to understand an astonishingly wide variety of C++
constructs, but its generated bindings are still <code>unsafe</code> functions
with lots of pointers involved.</p>
<pre class="mermaid">sequenceDiagram
   Rust--&gt;&gt;extern: unsafe Rust function call
   extern--&gt;&gt;C: call from Rust to C++
   participant extern as Bindgen generated bindings
   participant C as Existing C++ function
</pre>
<p>Interacting with <code>bindgen</code>-generated bindings requires unsafe Rust;
you will likely have to manually craft idiomatic safe Rust wrappers.
This is time-consuming and error-prone.</p>
<p><a href="https://cxx.rs">cxx</a> automates a lot of that process. Unlike <code>bindgen</code>
it doesn't learn about functions from existing C++ headers. Instead,
you specify cross-language interfaces in a Rust-like interface definition
language (IDL) within your Rust file. cxx generates both C++ and Rust code
from that IDL, marshaling data behind the scenes on both sides such that
you can use standard language features in your code. For example, you'll
find idiomatic Rust wrappers for <a href="https://docs.rs/cxx/1.0.50/cxx/struct.CxxString.html"><code>std::string</code></a>
and <a href="https://docs.rs/cxx/1.0.50/cxx/struct.UniquePtr.html"><code>std::unique_ptr</code></a>
and idiomatic C++ wrappers for <a href="https://cxx.rs/binding/slice.html">a Rust slice</a>.</p>
<pre class="mermaid">sequenceDiagram
   Rust--&gt;&gt;rsbindings: safe idiomatic Rust function call
   rsbindings--&gt;&gt;cxxbindings: hidden C ABI call using marshaled data
   cxxbindings--&gt;&gt;cpp: call to standard idiomatic C++
   participant rsbindings as cxx-generated Rust code
   participant cxxbindings as cxx-generated C++ code
   participant cpp as C++ function using STL types
</pre>
<blockquote>
<p>In the bindgen case even more work goes into wrapping idiomatic C++ signatures into something bindgen compatible: unique ptrs to raw ptrs, Drop impls on the Rust side, translating string types ... etc. The typical real-world binding we've converted from bindgen to cxx in my codebase has been -500 lines (mostly unsafe code) +300 lines (mostly safe code; IDL included). - DT</p>
</blockquote>
<p>The greatest benefit is that cxx sufficiently understands C++ STL
object ownership norms that the generated bindings can be used from
safe Rust code.</p>
<p>At present, there is no established solution which combines the idiomatic, safe
interoperability offered by <code>cxx</code> with the automatic generation offered by
<code>bindgen</code>. It's not clear whether this is even <em>possible</em> but <a href="https://github.com/google/autocxx">several</a>
<a href="https://github.com/google/mosaic">projects</a> are aiming in this direction.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="third_party/mermaid/mermaid.min.js"></script>
                <script type="text/javascript" src="third_party/mermaid/mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
