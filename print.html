<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cppfaq.rs</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="code.html"><strong aria-hidden="true">2.</strong> Questions about code in function bodies</a></li><li class="chapter-item expanded "><a href="signatures.html"><strong aria-hidden="true">3.</strong> Questions about your function signatures</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">4.</strong> Questions about your types</a></li><li class="chapter-item expanded "><a href="apis.html"><strong aria-hidden="true">5.</strong> Questions about your APIs</a></li><li class="chapter-item expanded "><a href="codebase.html"><strong aria-hidden="true">6.</strong> Questions about your whole codebase</a></li><li class="chapter-item expanded "><a href="processes.html"><strong aria-hidden="true">7.</strong> Questions about your processes</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">cppfaq.rs</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/google/rust-design-faq" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>So, you're coming from C++ and want to write Rust? Great!</p>
<p>You have questions? We have answers.</p>
<p>This book is a collection of frequently asked questions for those arriving from existing C++ codebases. It guides you on how to adapt your C++ thinking to the new facilities available in Rust. It should help you if you're coming from other object-oriented languages such as Java too.</p>
<p>Although it's structured as questions and answers, it can also be read front-to-back, to give you hints about how to adapt your C++/Java thinking to a more idiomatically Rusty approach.</p>
<p>It does not aim to teach you Rust - there are <a href="https://www.rust-lang.org/learn">many better resources</a>. It doesn't aim to talk about Rust idioms <em>in general</em> - <a href="https://rust-unofficial.github.io/patterns/idioms/index.html">there are great existing guides for that</a>. This guide is specifically about transitioning from some other traditionally OO language. If you're coming from such a language, you'll have questions about how to achieve the same outcomes in idiomatic Rust. That's what this guide is for.</p>
<h1 id="structure"><a class="header" href="#structure">Structure</a></h1>
<p>The guide starts with idioms at the small scale - answering questions about how you'd write a few lines of code - and moves towards ever larger patterns - answering questions about how you'd structure your whole codebase.</p>
<h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>The following awesome people helped write the answers here, and they're sometimes quoted using the abbreviations given.</p>
<p>Thanks to Adam Perry<a href="https://twitter.com/__anp__">(@__anp__)</a> (AP), Alyssa Haroldsen <a href="https://twitter.com/kupiakos">(@kupiakos)</a> (AH), Augie Fackler (AF), David Tolnay <a href="https://twitter.com/davidtolnay">(@davidtolnay)</a> (DT), Łukasz Anforowicz (LA), Manish Goregaokar <a href="https://twitter.com/ManishEarth">(@ManishEarth)</a> (MG), Mike Forster (MF), Miguel Young de la Sota <a href="https://twitter.com/DrawsMiguel">(@DrawsMiguel)</a> (MY), and Tyler Mandry <a href="https://twitter.com/tmandry">(@tmandry)</a> (TM).</p>
<p>Their views have been edited and collated by Adrian Taylor <a href="https://twitter.com/adehohum">(@adehohum)</a>, Chris Palmer, <a href="mailto:danakj@chromium.org">danakj@chromium.org</a> and Martin Brænne. Any errors or misrepresentations are ours.</p>
<p>Licensed under either of Apache License, Version 2.0 or MIT license at your option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-code-in-function-bodies"><a class="header" href="#questions-about-code-in-function-bodies">Questions about code in function bodies</a></h1>
<h2 id="how-can-i-avoid-the-performance-penalty-of-bounds-checks"><a class="header" href="#how-can-i-avoid-the-performance-penalty-of-bounds-checks">How can I avoid the performance penalty of bounds checks?</a></h2>
<p>Rust array and list accesses are all bounds checked. You may be worried about a performance penalty. How can you avoid that?</p>
<blockquote>
<p>Contort yourself a little bit to use iterators. - MY</p>
</blockquote>
<p>Rust gives you choices around functional versus imperative style, but things often work better in a functional style. Specifically - if you've got something iterable, then there are probably functional methods to do what you want.</p>
<p>For instance, suppose you need to work out what food to get at the petshop. Here's code that does this in an imperative style:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_a() -&gt; HashSet&lt;&amp;'static str&gt; {
    let mut meals_needed = HashSet::new();
    for n in 0..PETS.len() { // ugh
        if PETS[n].is_hungry {
            meals_needed.insert(PETS[n].meal_needed);
        }
    }
    meals_needed
}
<span class="boring">}
</span></code></pre></pre>
<p>The loop index is verbose and error-prone. Let's get rid of it and loop over an iterator instead:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_b() -&gt; HashSet&lt;&amp;'static str&gt;  {
    let mut meals_needed = HashSet::new();
    for animal in PETS.iter() { // better...
        if animal.is_hungry {
            meals_needed.insert(animal.meal_needed);
        }
    }
    meals_needed
}
<span class="boring">}
</span></code></pre></pre>
<p>We're accessing the loop through an iterator, but we're still processing the elements inside a loop. It's often more idiomatic to replace the loop with a chain of iterators:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Copyright 2020 Google LLC
</span><span class="boring">//
</span><span class="boring">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span><span class="boring">// you may not use this file except in compliance with the License.
</span><span class="boring">// You may obtain a copy of the License at
</span><span class="boring">//
</span><span class="boring">//    https://www.apache.org/licenses/LICENSE-2.0
</span><span class="boring">//
</span><span class="boring">// Unless required by applicable law or agreed to in writing, software
</span><span class="boring">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span><span class="boring">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="boring">// See the License for the specific language governing permissions and
</span><span class="boring">// limitations under the License.
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">static PETS: [Animal; 4] = [
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Dog&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Python&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Cat&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Cat&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">    Animal {
</span><span class="boring">        kind: &quot;Lion&quot;,
</span><span class="boring">        is_hungry: false,
</span><span class="boring">        meal_needed: &quot;Kibble&quot;,
</span><span class="boring">    },
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">    kind: &quot;Duck&quot;,
</span><span class="boring">    is_hungry: true,
</span><span class="boring">    meal_needed: &quot;pondweed&quot;,
</span><span class="boring">};
</span>fn make_shopping_list_c() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect() // best...
}
<span class="boring">}
</span></code></pre></pre>
<p>The obvious advantage of the third approach is that it's more concise, but less obviously:</p>
<ul>
<li>The first solution may require Rust to do array bounds checks inside each iteration of the loop, making Rust potentially slower than C++. In this sort of simple example, it likely wouldn't, but functional pipelines simply don't require bounds checks.</li>
<li>The final container (a <code>HashSet</code> in this case) may be able to allocate roughly the right size at the outset, using the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint">size_hint</a> of a Rust iterator.</li>
<li>If you use iterator-style code rather than imperative code, it's more likely the Rust compiler will be able to <a href="https://medium.com/swlh/an-adventure-in-simd-b0e8db4ccca7">auto-vectorize using SIMD instructions</a>.</li>
<li>There is no mutable state within the function. This makes it easier to verify that the code is correct and to avoid introducing bugs when changing it. In this simple example it may be obvious that calling the <code>HashSet::insert</code> is the only mutation to the set, but in more complex scenarios it is quite easy to lose the overview.</li>
<li>And as a new arrival from C++, you may find this hard to believe: For an experienced Rustacean it'll be more readable.</li>
</ul>
<p>Here are some more iterator techniques to help avoid materializing a collection:</p>
<ul>
<li>
<p>You can <a href="https://doc.rust-lang.org/std/iter/struct.Chain.html">chain two iterators together</a> to make a longer one.</p>
</li>
<li>
<p>If you need to iterate two lists, <a href="https://doc.rust-lang.org/std/iter/struct.Zip.html">zip them together</a> to avoid bounds checks on either.</p>
</li>
<li>
<p>If you want to feed all your animals, and also feed a nearby duck, just chain the iterator to <code>std::iter::once</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">static PETS: [Animal; 0] = [];
</span><span class="boring"> static NEARBY_DUCK: Animal = Animal {
</span><span class="boring">        kind: &quot;Duck&quot;,
</span><span class="boring">        is_hungry: true,
</span><span class="boring">        meal_needed: &quot;pondweed&quot;,
</span><span class="boring">    };
</span>fn make_shopping_list_d() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .chain(std::iter::once(&amp;NEARBY_DUCK))
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>(Similarly, if you want to add one more item to the shopping list - maybe you're hungry, as well as your menagerie? - just add it after the <code>map</code>).</p>
</li>
<li>
<p><code>Option</code> is iterable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">struct Animal {
</span><span class="boring">    kind: &amp;'static str,
</span><span class="boring">    is_hungry: bool,
</span><span class="boring">    meal_needed: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">static PETS: [Animal; 0] = [];
</span><span class="boring">struct Pond;
</span><span class="boring">static MY_POND: Pond = Pond;
</span>fn pond_inhabitant(pond: &amp;Pond) -&gt; Option&lt;&amp;Animal&gt; {
    // ...
<span class="boring">   None
</span>}

fn make_shopping_list_e() -&gt; HashSet&lt;&amp;'static str&gt; {
    PETS.iter()
        .chain(pond_inhabitant(&amp;MY_POND))
        .filter(|animal| animal.is_hungry)
        .map(|animal| animal.meal_needed)
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>Here's a diagram showing how data flows in this iterator pipeline:</p>
</li>
</ul>
<pre class="mermaid">flowchart LR
    %%{ init: { 'flowchart': { 'nodeSpacing': 40, 'rankSpacing': 15 } } }%%
      Pets
      Filter([filter by hunger])
      Map([map to noms])
      Meals
      uniqueify([uniqueify])
      shopping[Shopping list]
      Pets ---&gt; Filter
      Pond
      Pond ---&gt; inhabitant
      inhabitant[Optional pond inhabitant]
      inhabitant ---&gt; Map
      Filter ---&gt; Map
      Map ---&gt; Meals
      Meals ---&gt; uniqueify
      uniqueify ---&gt; shopping
</pre>
<ul>
<li>Here are other iterator APIs that will come in useful:
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned">cloned</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten">flatten</a></li>
</ul>
</li>
</ul>
<p>C++20 recently introduced <a href="https://en.cppreference.com/w/cpp/ranges">ranges</a>, a feature that allows you to pipeline operations on a collection similar to the way Rust iterators do, so this style of programming is likely to become more common in C++ too.</p>
<p>To summarize: While in C++ you tend to operate on collections by performing a series of operations on each individual item, in Rust you'll typically apply a pipeline of operations to the whole collection. Make this mental switch and your code will not just become more idiomatic but more efficient, too.</p>
<h2 id="isnt-it-confusing-to-use-the-same-variable-name-twice"><a class="header" href="#isnt-it-confusing-to-use-the-same-variable-name-twice">Isn't it confusing to use the same variable name twice?</a></h2>
<p>In Rust, it's common to reuse the same name for multiple variables in a function. For a C++ programmer, this is weird, but there are two good reasons to do it:</p>
<ul>
<li>
<p>You may no longer need to change a mutable variable after a certain point, and if your code is sufficiently complex you might want the compiler to guarantee this for you:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn spot_ate_my_slippers() -&gt; bool {
</span><span class="boring">    false
</span><span class="boring">}
</span><span class="boring">fn feed(_: &amp;str) {}
</span>let mut good_boy = &quot;Spot&quot;;
if spot_ate_my_slippers() {
    good_boy = &quot;Rover&quot;;
}
let good_boy = good_boy; // never going to change my dog again, who's a good boy
feed(&amp;good_boy);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Another common pattern is to retain the same variable name as you gradually unwrap things to a simpler type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let url = &quot;http://foo.com:1234&quot;;
</span>let port_number = url.split(&quot;:&quot;).skip(2).next().unwrap();
    // hmm, maybe somebody else already wrote a better URL parser....? naah, probably not
let port_number = port_number.parse::&lt;u16&gt;().unwrap();
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h2 id="how-can-i-avoid-the-performance-penalty-of-unwrap"><a class="header" href="#how-can-i-avoid-the-performance-penalty-of-unwrap">How can I avoid the performance penalty of <code>unwrap()</code>?</a></h2>
<p>C++ has no equivalent to Rust's <code>match</code>, so programmers coming from C++ often underuse it.</p>
<p>A heuristic: if you find yourself <code>unwrap()</code>ing, <em>especially</em> in an <code>if</code>/<code>else</code> statement, you should restructure your code to use a more sophisticated <code>match</code>.</p>
<p>For example, note the <code>unwrap()</code> in here (implying some runtime branch):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_parse() -&gt; Result&lt;u64,std::num::ParseIntError&gt; {
</span><span class="boring">let s = &quot;0x64a&quot;;
</span>if s.starts_with(&quot;0x&quot;) {
    u64::from_str_radix(s.strip_prefix(&quot;0x&quot;).unwrap(), 16)
} else {
    s.parse::&lt;u64&gt;()
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>and no extra <code>unwrap()</code> here:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_parse() -&gt; Result&lt;u64,std::num::ParseIntError&gt; {
</span><span class="boring">let s = &quot;0x64a&quot;;
</span>match s.strip_prefix(&quot;0x&quot;) {
    None =&gt; s.parse::&lt;u64&gt;(),
    Some(remainder) =&gt; u64::from_str_radix(remainder, 16),
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> and <code>matches!</code> are just as good as <code>match</code> but sometimes a little more concise. <code>cargo clippy</code> will usually tell you if you're using a <code>match</code> which can be simplified to one of those other two constructions.</p>
<h2 id="how-do-i-access-variables-from-within-a-spawned-thread"><a class="header" href="#how-do-i-access-variables-from-within-a-spawned-thread">How do I access variables from within a spawned thread?</a></h2>
<p>Use <a href="https://doc.rust-lang.org/nightly/std/thread/fn.scope.html"><code>std::thread::scope</code></a>.</p>
<h2 id="when-should-i-use-runtime-checks-vs-jumping-through-hoops-to-do-static-checks"><a class="header" href="#when-should-i-use-runtime-checks-vs-jumping-through-hoops-to-do-static-checks">When should I use runtime checks vs jumping through hoops to do static checks?</a></h2>
<p>Everyone learns Rust a different way, but it's said that some people reach a
point of &quot;trait mania&quot; where they try to encode <em>too much</em> via the type
system, and get in a mess. So, in learning Rust, you will want to strike a
balance between runtime checks (easy) or static compile-time checks (more
efficient but requires deeper understanding.)</p>
<blockquote>
<p>It’s very personal - some people learn better if they opt out of
language features, others not. - MG</p>
</blockquote>
<p>Some heuristics for how to keep things simple during the beginning of your
Rust journey:</p>
<ul>
<li>It's OK to start with lots of <code>.unwrap()</code>, cloning and <code>Arc</code>/<code>Rc</code>.</li>
<li>Start to use more advanced language features when you feel annoyed with
the amount of boilerplate. (As an expert, you'll switch to a different
strategy which is to consider the virality of your choices through the
codebase.)</li>
<li>Don't use traits until you have to. You might (for instance) need to use
a trait to make some code unit testable, but overoptimizing for that too
soon is a mistake. Some say that it's wise initially to avoid defining
any new traits at all.</li>
<li>Try to keep types smaller.</li>
</ul>
<p>Specifically on reference counting,</p>
<blockquote>
<p>If using Rc means you can avoid a lifetime parameter which is in half the
APIs in the project, that’s a very reasonable choice. If it avoids a single
lifetime somewhere, probably not a good idea. But measure before deciding. - MG</p>
</blockquote>
<p>If you want to bail out of the complexity of static checks, which runtime checks
are OK?</p>
<ul>
<li><code>unwrap()</code> and <code>Option</code> is mostly fine.</li>
<li><code>Arc</code> and <code>Rc</code> is also fine in most cases.</li>
<li>Extensive use of <code>clone()</code> is fine but will have a performance impact.</li>
<li><code>Cell</code> is regarded as a code smell and suggests you don't understand your
lifetimes - it should be used sparingly.</li>
<li><code>unsafe</code> is definitely not OK. It's harder to write <code>unsafe</code> Rust than to write
C or C++, because Rust has additional aliasing rules. If you're reaching for
<code>unsafe</code> to work around the complexity of Rust's static type system, as a
relative Rust beginner, please reconsider and look into the other options
listed above.</li>
</ul>
<p>Doing lifetime magic — where &quot;magic&quot; means annotating a function or complex
type with more than 1 lifetime, or other wizardry — is often an optimization
that you can defer until later. In the beginning, and when writing small
programs that you only intend to use a few times ('scripts'), copying is fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-your-function-signatures"><a class="header" href="#questions-about-your-function-signatures">Questions about your function signatures</a></h1>
<h2 id="should-i-return-an-iterator-or-a-collection"><a class="header" href="#should-i-return-an-iterator-or-a-collection">Should I return an iterator or a collection?</a></h2>
<blockquote>
<p>Pretty much always return an iterator. - AH</p>
</blockquote>
<p>We suggested you <a href="./code.html#how-can-i-avoid-the-performance-penalty-of-bounds-checks">use iterators a lot in your code</a>. Share the love! Give iterators to your callers too.</p>
<p>If you <em>know</em> your caller will store the items you're returning in a concrete collection, such as a <code>Vec</code> or a <code>HashSet</code>, you may want to return that. In all other cases, return an iterator.</p>
<p>Your caller might:</p>
<ul>
<li>Collect the iterator into a <code>Vec</code></li>
<li>Collect it into a <code>HashSet</code> or some other specialized container</li>
<li>Loop over the items</li>
<li>Filter them or otherwise completely ignore some</li>
</ul>
<p>Collecting the items into vector will only turn out to be right in one of these cases. In the other cases, you're wasting memory and CPU time by building a concrete collection.</p>
<p>This is weird for C++ programmers because iterators don't usually have robust references into the underlying data. Even Java iterators are scary, throwing <code>ConcurrentModificationExceptions</code> when you least expect it. Rust prevents that, at compile time. If you <em>can</em> return an iterator, you should.</p>
<pre class="mermaid">flowchart LR
    subgraph Caller
    it_ref[reference to iterator]
    end
    subgraph it_outer[Iterator]
    it[Iterator]
    it_ref --reference--&gt; it
    end
    subgraph data[Underlying data]
    dat[Underlying data]
    it --reference--&gt; dat
    end
</pre>
<h2 id="how-flexible-should-my-parameters-be"><a class="header" href="#how-flexible-should-my-parameters-be">How flexible should my parameters be?</a></h2>
<p>Which of these is best?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn a(params: &amp;[String]) {
    // ...
}

fn b(params: &amp;[&amp;str]) {
    // ...
}

fn c(params: &amp;[impl AsRef&lt;str&gt;]) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>(You'll need to make an equivalent decision in other cases, e.g. <code>Path</code> versus <code>PathBuf</code> versus <code>AsRef&lt;Path&gt;</code>.)</p>
<p>None of the options is clearly superior; for each option, there's a case it can't handle that the others can:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn a(params: &amp;[String]) {
</span><span class="boring">}
</span><span class="boring">fn b(params: &amp;[&amp;str]) {
</span><span class="boring">}
</span><span class="boring">fn c(params: &amp;[impl AsRef&lt;str&gt;]) {
</span><span class="boring">}
</span>fn main() {
    a(&amp;[]);
    // a(&amp;[&quot;hi&quot;]); // doesn't work
    a(&amp;vec![format!(&quot;hello&quot;)]);

    b(&amp;[]);
    b(&amp;[&quot;hi&quot;]);
    // b(&amp;vec![format!(&quot;hello&quot;)]); // doesn't work

    // c(&amp;[]); // doesn't work
    c(&amp;[&quot;hi&quot;]);
    c(&amp;vec![format!(&quot;hello&quot;)]);
}
</code></pre></pre>
<p>So you have a variety of interesting ways to <em>slightly</em> annoy your callers under different circumstances. Which is best?</p>
<p><code>AsRef</code> has some advantages: if a caller has a <code>Vec&lt;String&gt;</code>, they can use that directly, which would be impossible with the other options. But if they want to pass an empty list, they'll have to explicitly specify the type (for instance <code>&amp;Vec::&lt;String&gt;::new()</code>).</p>
<blockquote>
<p>Not a huge fan of AsRef everywhere - it's just saving the caller typing. If you have lots of AsRef then nothing is object-safe. - MG</p>
</blockquote>
<p>TL;DR: choose the middle option, <code>&amp;[&amp;str]</code>. If your caller happens to have a vector of <code>String</code>, it's relatively little work to get a slice of <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn b(params: &amp;[&amp;str]) {
</span><span class="boring">}
</span>
fn main() {
    // Instead of b(&amp;vec![format!(&quot;hello&quot;)]);
    let hellos = vec![format!(&quot;hello&quot;)];
    b(&amp;hellos.iter().map(String::as_str).collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<h2 id="how-do-i-overload-constructors"><a class="header" href="#how-do-i-overload-constructors">How do I overload constructors?</a></h2>
<p>You can't do this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct BirthdayCard {}
</span>impl BirthdayCard {
    fn new(name: &amp;str) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }

    // Can't add more overloads:
    //
    // fn new(name: &amp;str, age: i32) -&gt; BirthdayCard { ... }
    //
    // fn new(name: &amp;str, text: &amp;str) -&gt; BirthdayCard { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have a default constructor, and a few variants for other cases, you can simply write them as different static methods. An idiomatic way to do this is to write a <code>new()</code> constructor and then <code>with_foo()</code> constructors that apply the given &quot;foo&quot; when constructing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Racoon {}
</span>impl Racoon {
    fn new() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
    fn with_age(age: usize) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have have a bunch of constructors and no default, it may make sense to instead provide a set of <code>new_foo()</code> constructors.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Animal {}
</span>impl Animal {
    fn new_squirrel() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
    fn new_badger() -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For a more complex situation, you may use <a href="https://rust-lang.github.io/api-guidelines/type-safety.html#builders-enable-construction-of-complex-values-c-builder">the builder pattern</a>. The builder has a set of methods which take <code>&amp;mut self</code> and return <code>&amp;mut Self</code>. Then add a <code>build()</code> that returns the final constructed object.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BirthdayCard {}

struct BirthdayCardBuilder {}
impl BirthdayCardBuilder {
    fn new(name: &amp;str) -&gt; Self {
<span class="boring">      Self{}
</span>        // ...
    }

    fn age(&amp;mut self, age: i32) -&gt; &amp;mut Self {
<span class="boring">        self
</span>        // ...
    }

    fn text(&amp;mut self, text: &amp;str) -&gt; &amp;mut Self {
<span class="boring">        self
</span>        // ...
    }

    fn build(&amp;mut self) -&gt; BirthdayCard { BirthdayCard { /* ... */ } }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can then <a href="https://rust-lang.github.io/api-guidelines/type-safety.html#non-consuming-builders-preferred">chain these</a> into short or long constructions, passing parameters as necessary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct BirthdayCard {}
</span><span class="boring">
</span><span class="boring">struct BirthdayCardBuilder {}
</span><span class="boring">impl BirthdayCardBuilder {
</span><span class="boring">    fn new(name: &amp;str) -&gt; BirthdayCardBuilder {
</span><span class="boring">      Self{}
</span><span class="boring">      // ...
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn age(&amp;mut self, age: i32) -&gt; &amp;mut BirthdayCardBuilder {
</span><span class="boring">        self
</span><span class="boring">        // ...
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn text(&amp;mut self, text: &amp;str) -&gt; &amp;mut BirthdayCardBuilder {
</span><span class="boring">        self
</span><span class="boring">        // ...
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">    fn build(&amp;mut self) -&gt; BirthdayCard { BirthdayCard { /* ... */ } }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let card = BirthdayCardBuilder::new(&quot;Paul&quot;)
        .age(64)
        .text(&quot;Happy Valentine's Day!&quot;)
        .build();
}
</code></pre></pre>
<p>Note another advantage of builders: Overloaded constructors often don't provide all possible combinations of parameters, whereas with the builder pattern, you can combine exactly the parameters you want.</p>
<h2 id="when-must-i-use-must_use"><a class="header" href="#when-must-i-use-must_use">When must I use <code>#[must_use]</code>?</a></h2>
<blockquote>
<p>Use it on Results and mutex locks. - MG</p>
</blockquote>
<p><code>#[must_use]</code> causes a compile error if the caller ignores the return value.</p>
<p>Rust functions are often single-purpose. They either:</p>
<ul>
<li>Return a value without any side effects; or</li>
<li>Do something (i.e. have side effects) and return nothing.</li>
</ul>
<p>In neither case do you need to think about <code>#[must_use]</code>. (In the first case,
nobody would call your function unless they were going to use the result.)</p>
<p><code>#[must_use]</code> is useful for those rarer functions which return a result <em>and</em>
have side effects. In most such cases, it's wise to specify <code>#[must_use]</code>, unless
the return value is truly optional (for example in
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert"><code>HashMap::insert</code></a>).</p>
<h2 id="when-should-i-take-parameters-by-value"><a class="header" href="#when-should-i-take-parameters-by-value">When should I take parameters by value?</a></h2>
<p>Move semantics are more common in Rust than in C++.</p>
<blockquote>
<p>In C++ moves tend to be an optimization, whereas in Rust they're a key semantic part of the program. - MY</p>
</blockquote>
<p>To a first approximation, you should assume similar performance when passing
things by (moved) value or by reference. It's true that a move may turn out to
be a <code>memcpy</code>, but it's often optimized away.</p>
<blockquote>
<p>Express the ownership relationship in the type system, instead of trying to second-guess the compiler for efficiency. - AF</p>
</blockquote>
<p>The moves are, of course, destructive - and unlike in C++, the compiler
enforces that you don't reuse a variable that has been moved.
Some C++ objects become toxic after they've moved; that's not a
risk in Rust.</p>
<p>So here's the heuristic: if a caller shouldn't be able to use an object again,
pass it via move semantics in order to consume it.</p>
<p>An extreme example: a UUID is supposed to be globally unique - it might cause a
logic error for a caller to retain knowledge of a UUID after passing it to a callee.</p>
<p>More generally, consume data enthusiastically to avoid logical errors during future
refactorings. For instance, if some command-line options are overridden by a
runtime choice, consume those old options - then any future refactoring which
uses them after that point will give you a compile error. This pattern is
surprisingly effective at spotting errors in your assumptions.</p>
<h2 id="should-i-ever-take-self-by-value"><a class="header" href="#should-i-ever-take-self-by-value">Should I ever take <code>self</code> by value?</a></h2>
<p>Sometimes. If you've got a member function which destroys or transforms a thing,
it should take <code>self</code> by value. Examples:</p>
<ul>
<li>Closing a file and returning a result code.</li>
<li>A builder-pattern object which spits out the thing it was building. (<a href="https://docs.rs/bindgen/0.59.0/bindgen/struct.Builder.html#method.generate">Example</a>).</li>
</ul>
<h2 id="how-do-i-take-a-thing-and-a-reference-to-something-within-that-thing"><a class="header" href="#how-do-i-take-a-thing-and-a-reference-to-something-within-that-thing">How do I take a thing, and a reference to something within that thing?</a></h2>
<p>For example, suppose you want to give all of your dogs to your friend, yet also
tell your friend which one of the dogs is the Best Boy or Girl.</p>
<pre><code class="language-cpp">struct PetInformation {
  std::vector&lt;Dog&gt; dogs;
  Dog&amp; BestBoy;
  Dog&amp; BestGirl;
}

PetInformation GetPetInformation() {
  // ...
}
</code></pre>
<p>Generally this is an indication that your types or functions are not split down
in the correct
way:</p>
<blockquote>
<p>This is a decomposition problem. Once you’ve found the correct decomposition, everything
else just works. The code almost writes itself. - AF</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Dog;
</span>struct PetInformation(Vec&lt;Dog&gt;);

fn get_pet_information() -&gt; PetInformation {
  // ...
<span class="boring">PetInformation(Vec::new())
</span>}

fn identify_best_boy(pet_information: &amp;PetInformation) -&gt; &amp;Dog {
  // ...
<span class="boring">  pet_information.0.get(0).unwrap()
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>One use-case is when you want to act on some data, depending on its contents...
but you also wanted to do something with those contents that you previously
identified.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Key;
</span>struct Door { locked: bool }

struct Car {
  ignition: Option&lt;Key&gt;,
  door: Door,
}

fn steal_car(car: Car) {
  match car {
    Car {
      ignition: Some(ref key),
      door: Door { locked: false }
    } =&gt; drive_away_normally(car /* , key */),
    _ =&gt; break_in_and_hotwire(car)
  }
}

fn drive_away_normally(car: Car /* , key: &amp;Key */) {
  // Annoying to have to repeat this code...
  let key = match car {
    Car {
      ignition: Some(ref key),
      ..
    } =&gt; key,
    _ =&gt; unreachable!()
  };
  turn_key(key);
  // ...
}

<span class="boring">fn turn_key(key: &amp;Key) {}
</span><span class="boring">fn break_in_and_hotwire(car: Car) {}
</span><span class="boring">}
</span></code></pre></pre>
<p>If this repeated matching gets annoying, it's relatively easy
to extract it to a function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn turn_key(key: &amp;Key) {}
</span><span class="boring">fn break_in_and_hotwire(car: Car) {}
</span><span class="boring">struct Key;
</span><span class="boring">struct Door { locked: bool }
</span><span class="boring">struct Car {
</span><span class="boring">  ignition: Option&lt;Key&gt;,
</span><span class="boring">  door: Door,
</span><span class="boring">}
</span>
impl Car {
  fn get_usable_key(&amp;self) -&gt; Option&lt;&amp;Key&gt; {
    match self {
      Car {
        ignition: Some(ref key),
        door: Door { locked: false }
      } =&gt; Some(key),
      _ =&gt; None,
    }
  }
}

fn steal_car(car: Car) {
  match car.get_usable_key() {
    None =&gt; break_in_and_hotwire(car),
    Some(_) =&gt; drive_away_normally(car),
  }
}

fn drive_away_normally(car: Car) {
  turn_key(car.get_usable_key().unwrap());
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="when-should-i-return-impl-trait"><a class="header" href="#when-should-i-return-impl-trait">When should I return <code>impl Trait</code>?</a></h2>
<p>Your main consideration should be API stability. If your caller doesn't
<em>need</em> to know the concrete implementation type, then don't tell it. That
gives you flexibility to change your implementation in future without breaking
compatibility.</p>
<p>Note <a href="https://www.hyrumslaw.com/">Hyrum's Law</a>!</p>
<p>Using <code>impl Trait</code> doesn't solve <em>all</em> possible API stability concerns, because
even <code>impl Trait</code> leaks auto-traits such as <code>Send</code> and <code>Sync</code>.</p>
<h2 id="i-miss-function-overloading-what-do-i-do"><a class="header" href="#i-miss-function-overloading-what-do-i-do">I miss function overloading! What do I do?</a></h2>
<p>Use a trait to implement the behavior you used to have.</p>
<p>For example, in C++:</p>
<pre><code class="language-cpp">class Dog {
public:
  void eat(Dogfood);
  void eat(DeliveryPerson);
};
</code></pre>
<p>In Rust you might express this as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Edible {
};

struct Dog;

impl Dog {
  fn eat(edible: impl Edible) {
    // ...
  }
}

struct Dogfood;
struct DeliveryPerson;

impl Edible for Dogfood {}
impl Edible for DeliveryPerson {}
<span class="boring">}
</span></code></pre></pre>
<p>This gives your caller all the convenience they want, though may increase
work for you as the implementer.</p>
<h2 id="i-miss-operator-overloading-what-do-i-do"><a class="header" href="#i-miss-operator-overloading-what-do-i-do">I miss operator overloading! What do I do?</a></h2>
<p>Implement the standard traits instead (for example <code>PartialEq</code>, <code>Add</code>). This
has equivalent effect in that folks will be able to use your type in a standard
Rusty way without knowing too much special about your type.</p>
<h2 id="should-i-return-an-error-or-panic"><a class="header" href="#should-i-return-an-error-or-panic">Should I return an error, or panic?</a></h2>
<p>Panics should be used only for invariants, never for anything that you believe
might happen. That's especially true <a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">for libraries</a></p>
<ul>
<li>panicking (or asserting) should be reserved for the 'top level' code driving
the application.</li>
</ul>
<blockquote>
<p>Libraries which panic are super-rude and I hate them - MY</p>
</blockquote>
<p>Even in your own application code, panicking might not be wise:</p>
<blockquote>
<p>Panicking in application logic for recoverable errors makes it way harder to librarify some code - AP</p>
</blockquote>
<p>If you really must have an API which can panic, add a <code>try_</code> equivalent too.</p>
<h2 id="what-should-my-error-type-be"><a class="header" href="#what-should-my-error-type-be">What should my error type be?</a></h2>
<p><a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code> type</a> is parameterized
over an error type. What should you use?</p>
<p>For app code, consider <a href="https://docs.rs/anyhow/">anyhow</a>. For library code,
use your own <code>enum</code> of error conditions - you can use <a href="https://docs.rs/thiserror/">thiserror</a>
to make this more pleasant.</p>
<h2 id="when-should-i-take-or-return-dyn-trait"><a class="header" href="#when-should-i-take-or-return-dyn-trait">When should I take or return <code>dyn Trait</code>?</a></h2>
<p>In either C++ or Rust, you can choose between monomorphization (that is, building
code multiple times for each permutation of parameter types) or dynamic dispatch (i.e.
looking up the correct implementation using vtables).</p>
<p>In C++ the syntax is completely different - templates vs virtual functions.
In Rust the syntax is almost identical - in some cases it's as simple as
exchanging the <code>impl</code> keyword with the <code>dyn</code> keyword.</p>
<p>Given this flexibility to switch strategies, which should you start with?</p>
<p>In both languages, monomorphization tends to result in a quicker program (partly
due to better inlining). It's arguably true that inlining is more important in
Rust, due to its functional nature and pervasive use of iterators. Whether or
not that's the reason, experienced Rustaceans usually start with <code>impl</code>:</p>
<blockquote>
<p>It's best practice to start with monomorphization and move to <code>dyn</code>... - MG</p>
</blockquote>
<p>The main cost of monomorphization is larger binaries. There are cases where
large amounts of code can end up being duplicated (the marvellous <a href="https://serde.rs/">serde</a>
is one).</p>
<p>You <em>can</em> choose to do things the other way round:</p>
<blockquote>
<p>... it’s workable practice to start with <code>dyn</code> and then move to <code>impl</code> when you have problems. - MG</p>
</blockquote>
<p><code>dyn</code> can be awkward, and potentially expensive in different ways:</p>
<blockquote>
<p>One thing to note about pervasive <code>dyn</code> is that because it unsizes the types it wraps, you need to box it if you want to store it by value. You end up with a good bit more allocator pressure if you try to have <code>dyn</code> field types. - AP</p>
</blockquote>
<h2 id="ai-seem-to-have-lots-of-named-lifetimes-am-bi-doing-something-wrong"><a class="header" href="#ai-seem-to-have-lots-of-named-lifetimes-am-bi-doing-something-wrong"><code>&lt;'a&gt;</code>I seem to have lots of named lifetimes. Am <code>&lt;'b&gt;</code>I doing something wrong?</a></h2>
<p>Some say that if you have a significant number of named lifetimes, you're
overcomplicating things.</p>
<p>There are some scenarios where multiple named lifetimes make perfect sense - for example
if you're dealing with an arena, or major phases of a process (the Rust compiler
has <code>'gcx</code> and <code>'tcx</code> lifetimes relating to the output of certain compile phases.)</p>
<p>But otherwise, it may be that you've got lifetimes because you're trying <em>too
hard</em> to avoid a copy. You may be better off simply switching to runtime
checking (e.g. <code>Rc</code>, <code>Arc</code>) or even cloning.</p>
<p>Are named lifetimes even a &quot;code smell&quot;?</p>
<blockquote>
<p>My experience has been that the extent to which they're a smell varies a good bit based on the programmer's experience level, which has led me towards increased skepticism over time. Lots of people learning Rust have experienced the pain of first not wanting to <code>.clone()</code> something, immediately putting lifetimes everywhere, and then feeling the pain of lifetime subtyping and variance. I don't think they're nearly as odorous as unsafe, for example, but treating them as a bit of a smell does I think lead to code that's easier to read for a newcomer and to refactor around the stack. - AP</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-your-types"><a class="header" href="#questions-about-your-types">Questions about your types</a></h1>
<h2 id="my-class-needs-mutable-references-to-other-things-to-do-its-job-other-classes-need-mutable-references-to-these-things-too-what-do-i-do"><a class="header" href="#my-class-needs-mutable-references-to-other-things-to-do-its-job-other-classes-need-mutable-references-to-these-things-too-what-do-i-do">My 'class' needs mutable references to other things to do its job. Other classes need mutable references to these things too. What do I do?</a></h2>
<p>It's common in C++ to have a class that contain mutable references to other
objects; the class mutates those objects to do its work. Often, there
are several classes that all hold a mutable reference to the same object. Here
is a diagram that illustrates this:</p>
<pre class="mermaid">flowchart LR
    subgraph Shared functionality
    important[Important Shared Object]
    end
    subgraph ObjectA
    methodA[Method]
    refa[Mutable Reference]--&gt;important
    methodA-. Acts on shared object.-&gt;important
    end
    subgraph ObjectB
    refb[Mutable Reference]--&gt;important
    methodB[Method]
    methodB-. Acts on shared object.-&gt;important
    end
    main --&gt; ObjectA
    main --&gt; ObjectB
    main-. Calls .-&gt; methodA
    main-. Calls .-&gt; methodB
</pre>
<p>In Rust, you can't have multiple mutable references to a shared object, so what
do you do?</p>
<p>First of all, consider moving behavior out of your types. (See
<a href="./codebase.html#the-c-observer-pattern-is-hard-in-rust-what-to-do">the answer about the observer pattern</a> and especially
<a href="./codebase.html#option-2-drive-the-objects-from-the-code-not-the-other-way-round">the second option described there</a>.)</p>
<p>Even in Rust, though, it's still often the best choice to make complex behavior
part of the type within <code>impl</code> blocks. You can still do that - but don't
<em>store</em> references. Instead, pass them into each function call.</p>
<pre class="mermaid">flowchart LR
    subgraph Shared functionality
    important[Important Shared Object]
    end
    subgraph ObjectA
    methodA[Method]
    methodA-. Acts on shared object.-&gt;important
    end
    subgraph ObjectB
    methodB[Method]
    methodB-. Acts on shared object.-&gt;important
    end
    main --&gt; ObjectA
    main --&gt; ObjectB
    main --&gt; important
    main-. Passes reference to shared object.-&gt; methodA
    main-. Passes reference to shared object.-&gt; methodB
</pre>
<p>Instead of this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantSharedObject;
</span><span class="boring">struct ObjectA&lt;'a&gt; {
</span><span class="boring">   important_shared_object: &amp;'a mut ImportantSharedObject,
</span><span class="boring">}
</span><span class="boring">impl&lt;'a&gt; ObjectA&lt;'a&gt; {
</span><span class="boring">   fn new(important_shared_object: &amp;'a mut ImportantSharedObject) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           important_shared_object
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">   fn do_something(&amp;mut self) {
</span><span class="boring">       // act on self.important_shared_object
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let mut shared_thingy = ImportantSharedObject;
    let mut a = ObjectA::new(&amp;mut shared_thingy);
    a.do_something(); // acts on shared_thingy
}
</code></pre></pre>
<p>Do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantSharedObject;
</span><span class="boring">struct ObjectA;
</span><span class="boring">impl ObjectA {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self
</span><span class="boring">   }
</span><span class="boring">   fn do_something(&amp;mut self, important_shared_object: &amp;mut ImportantSharedObject) {
</span><span class="boring">       // act on important_shared_object
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let mut shared_thingy = ImportantSharedObject;
    let mut a = ObjectA::new();
    a.do_something(&amp;mut shared_thingy); // acts on shared_thingy
}
</code></pre></pre>
<p>(Happily this also gets rid of named lifetime parameters.)</p>
<p>If you have a hundred such shared objects, you probably don't want a
hundred function parameters. So it's usual to bundle them up into
a context structure which can be passed into each function call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantSharedObject;
</span><span class="boring">struct AnotherImportantObject;
</span>struct Ctx&lt;'a&gt; {
    important_shared_object: &amp;'a mut ImportantSharedObject,
    another_important_object: &amp;'a mut AnotherImportantObject,
}

<span class="boring">struct ObjectA;
</span><span class="boring">impl ObjectA {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self
</span><span class="boring">   }
</span><span class="boring">   fn do_something(&amp;mut self, ctx: &amp;mut Ctx) {
</span><span class="boring">       // act on ctx.important_shared_object and ctx.another_important_thing
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let mut shared_thingy = ImportantSharedObject;
    let mut another_thingy = AnotherImportantObject;
    let mut ctx = Ctx {
        important_shared_object: &amp;mut shared_thingy,
        another_important_object: &amp;mut another_thingy,
    };
    let mut a = ObjectA::new();
    a.do_something(&amp;mut ctx); // acts on both the shared thingies
}
</code></pre></pre>
<pre class="mermaid">flowchart LR
    subgraph Shared functionality
    important[Important Shared Object]
    end
    subgraph Context
    refa[Mutable Reference]--&gt;important
    end
    subgraph ObjectA
    objectA[Object A]
    methodA[Method]
    methodA-. Acts on shared object.-&gt;important
    end
    subgraph ObjectB
    objectB[Object B]
    methodB[Method]
    methodB-. Acts on shared object.-&gt;important
    end
    main --&gt; objectA
    main --&gt; objectB
    main --&gt; Context
    main-. Passes context.-&gt; methodA
    main-. Passes context.-&gt; methodB
</pre>
<p>Even simpler: just put all the data directly into <code>Ctx</code>. But the key point
is that this context object is passed around into just about all function calls
rather than being stored anywhere, thus negating any borrowing/lifetime concerns.</p>
<p>This pattern can be seen in <a href="https://github.com/rust-lang/rust-bindgen/blob/271eeb0782d34942267ceabcf5f1cf118f0f5842/src/ir/context.rs#L308">bindgen</a>,
for example.</p>
<blockquote>
<p>Split out borrowing concerns from the object concerns. - MG</p>
</blockquote>
<p>To generalize this idea, try to avoid storing references to anything that might
need to be changed. Instead take those things as parameters. For instance
<code>petgraph</code> <a href="https://docs.rs/petgraph/0.6.0/petgraph/visit/trait.Walker.html">takes the entire graph as context to a <code>Walker</code> object</a>,
such that the graph can be changed while you're walking it.</p>
<h2 id="my-type-needs-to-store-arbitrary-user-data-what-do-i-do-instead-of-void-"><a class="header" href="#my-type-needs-to-store-arbitrary-user-data-what-do-i-do-instead-of-void-">My type needs to store arbitrary user data. What do I do instead of <code>void *</code>?</a></h2>
<p>Ideally, your type would know all possible types of user data that it could store.
You'd represent this as an <code>enum</code> with variant data for each possibility. This
would give complete compile-time type safety.</p>
<p>But sometimes code needs to store data for which it can't depend upon
the definition: perhaps it's defined by a totally different area of the
codebase, or belongs to clients. Such possibilities can't be enumerated in
advance. Until recently, the only real option in C++ was to use a <code>void *</code>
and have clients downcast to get their original type back. Modern C++ offers
a much better option, <code>std::any</code>; if you've come across that, Rust's equivalent
will seem very familiar.</p>
<p>In Rust, the <a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>Any</code></a> type
allows you to store <em>anything</em> and retrieve it later in a type-safe fashion:</p>
<pre><pre class="playground"><code class="language-rust">use std::any::Any;

struct MyTypeOfUserData(u8);

fn main() {
  let any_user_data: Box&lt;dyn Any&gt; = Box::new(MyTypeOfUserData(42));
  let stored_value = any_user_data.downcast_ref::&lt;MyTypeOfUserData&gt;().unwrap().0;
  println!(&quot;{}&quot;, stored_value);
}
</code></pre></pre>
<p>If you want to be more prescriptive about what can be stored, you can define
a trait (let's call it <code>UserData</code>) and store a <code>Box&lt;dyn UserData&gt;</code>.
Your trait should have a method <code>fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any;</code>
Each implementation can just return <code>self</code>.</p>
<p>Your caller can then do this:</p>
<pre><pre class="playground"><code class="language-rust">trait UserData {
  fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any;
  // ...other trait methods which you wish to apply to any UserData...
}

struct MyTypeOfUserData(u8);

impl UserData for MyTypeOfUserData {
  fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any { self }
}

fn main() {
  // Store a generic Box&lt;dyn UserData&gt;
  let user_data: Box&lt;dyn UserData&gt; = Box::new(MyTypeOfUserData(42));
  // Get back to a specific type
  let stored_value = user_data.as_any().downcast_ref::&lt;MyTypeOfUserData&gt;().unwrap().0;
  println!(&quot;{}&quot;, stored_value);
}
</code></pre></pre>
<p>Of course, enumerating all possible stored variants remains preferable such that the
compiler helps you to avoid runtime panics.</p>
<h2 id="when-should-i-put-my-data-in-a-box"><a class="header" href="#when-should-i-put-my-data-in-a-box">When should I put my data in a <code>Box</code>?</a></h2>
<p>In C++, you often need to box things for ownership reasons, whereas in Rust
it's typically just a performance trade-off. It's arguably premature optimization
to use boxes unless your profiling shows a lot of memcpy of that particular
type (or, perhaps, the relevant <a href="https://rust-lang.github.io/rust-clippy/v0.0.212/index.html#large_enum_variant">clippy lint</a>
informs you that you have a problem.)</p>
<blockquote>
<p>I never box things unless they're really big. - MG</p>
</blockquote>
<p>Another heuristic is if part of your data structure is very rarely filled,
in which case you may wish to <code>Box</code> it to avoid incurring an overhead for all
other instances of the type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Humility; struct Talent; struct Ego;
</span>struct Popstar {
  ego: Ego,
  talent: Talent,
  humility: Option&lt;Box&lt;Humility&gt;&gt;,
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>(This is one reason why people like using <a href="https://docs.rs/anyhow/latest/anyhow/">anyhow</a>
for their errors; it means the failure case in their <code>Result</code> enum is only
a pointer wide.)</p>
<p>Of course, Rust may require you to use a box:</p>
<ul>
<li>if you need to <code>Pin</code> some data, typically for async Rust, or</li>
<li>if you otherwise have an infinitely sized data structure</li>
</ul>
<p>but as usual, the compiler will explain very nicely.</p>
<h2 id="should-i-have-public-fields-or-accessor-methods"><a class="header" href="#should-i-have-public-fields-or-accessor-methods">Should I have public fields or accessor methods?</a></h2>
<p>The trade-offs are similar to C++ except that Rust's pattern-matching makes it
very convenient to match on fields, so within a realm of code that you own you
may bias towards having more public fields than you're used to. As with C++,
this can give you a future compatibility burden.</p>
<h2 id="when-should-i-use-a-newtype-wrapper"><a class="header" href="#when-should-i-use-a-newtype-wrapper">When should I use a newtype wrapper?</a></h2>
<p>The <a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html">newtype wrapper pattern</a>
uses Rust's type systems to enforce extra behavior without necessarily changing
the underlying representation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn get_rocket_length() -&gt; Inches { Inches(7) }
</span>struct Inches(u32);
struct Centimeters(u32);

fn build_mars_orbiter() {
  let rocket_length: Inches = get_rocket_length();
  // mate_to_orbiter(rocket_length); // does not compile because this takes cm
}
<span class="boring">}
</span></code></pre></pre>
<p>Other examples that have been used:</p>
<ul>
<li>An IP address which is guaranteed not to be localhost;</li>
<li>Non-zero numbers;</li>
<li>IDs which are guaranteed to be unique</li>
</ul>
<p>Such new types typically need a lot of boilerplate, especially to implement
the traits which users of your type would expect to find. On the other hand,
they allow you to use Rust's type system to statically prevent logic bugs.</p>
<p>A heuristic: if there are some invariants you'd be checking for at runtime,
see if you can use a newtype wrapper to do it statically instead. Although it
may be more code to start with, you'll <a href="code.html#When-should-I-use-runtime-checks-vs-jumping-through-hoops-to-do-static-checks">save the effort of finding and fixing
logic bugs later</a>.</p>
<h2 id="how-else-can-i-use-rusts-type-system-to-avoid-high-level-logic-bugs"><a class="header" href="#how-else-can-i-use-rusts-type-system-to-avoid-high-level-logic-bugs">How else can I use Rust's type system to avoid high-level logic bugs?</a></h2>
<p>Lots of ways:</p>
<h3 id="zero-sized-types"><a class="header" href="#zero-sized-types">Zero-sized types.</a></h3>
<p>Also known as &quot;ZSTs&quot;. These are types which occupy literally zero bytes, and
so (generally) make no difference whatsoever to the code generated. But you
can use them in the type system to enforce invariants at compile-time with
no runtime check.</p>
<p>For example, they're often used as capability tokens - you can statically
prove that code exclusively has the right to do something.</p>
<pre><pre class="playground"><code class="language-rust">pub trait ValidationStatus {}

mod validator {
  use self::super::{Bytecode, ValidationStatus};
  /// ZST marker to show that bytecode has been validated.
  // Private field ensures this can't be created outside this mod
  // but PhantomData means this is still zero-sized.
  pub struct BytecodeValidated(std::marker::PhantomData&lt;u8&gt;);
  pub fn validate_bytecode&lt;V: ValidationStatus&gt;(code: Bytecode&lt;V&gt;) -&gt; Bytecode&lt;BytecodeValidated&gt; {
    // Do expensive validation operation here...
   Bytecode {
    validated: BytecodeValidated(std::marker::PhantomData),
    code: code.code
   }
  }
  impl ValidationStatus for BytecodeValidated {}
}

struct BytecodeNotValidated;

impl ValidationStatus for BytecodeNotValidated {}

pub struct Bytecode&lt;V: ValidationStatus&gt; {
  validated: V,
  code: Vec&lt;u8&gt;,
}

fn run_bytecode(bytecode: &amp;Bytecode&lt;validator::BytecodeValidated&gt;) {
  // Compiler PROVES you validated it before you can run it. There are no
  // runtime branches involved.
}

fn get_unvalidated_bytecode() -&gt; Bytecode&lt;BytecodeNotValidated&gt; {
  // ...
<span class="boring">  Bytecode {
</span><span class="boring">   validated: BytecodeNotValidated,
</span><span class="boring">   code: Vec::new()
</span><span class="boring"> }
</span>}

fn main() {
  let bytecode = get_unvalidated_bytecode();
  // run_bytecode(bytecode); // does not compile
  let bytecode = validator::validate_bytecode(bytecode);
  run_bytecode(&amp;bytecode);
  run_bytecode(&amp;bytecode);
}
</code></pre></pre>
<p>ZSTs can also be used to demonstrate <em>exclusive</em> access to some resource.</p>
<pre><pre class="playground"><code class="language-rust">struct RobotArmAccessToken;

fn move_arm(token: &amp;mut RobotArmAccessToken, x: u32, y: u32, z: u32) {
  // ...
}

fn attach_car_door(token: &amp;mut RobotArmAccessToken) {
  move_arm(token, 3, 4, 6);
  move_arm(token, 5, 3, 6);
}

fn install_windscreen(token: &amp;mut RobotArmAccessToken) {
  move_arm(token, 7, 8, 2);
  move_arm(token, 1, 2, 3);
}

fn main() {
  let mut token = RobotArmAccessToken; // ensure only one exists
  attach_car_door(&amp;mut token);
  install_windscreen(&amp;mut token);
}
</code></pre></pre>
<p>(The type system would prevent these operations happening in parallel.)</p>
<h3 id="marker-traits"><a class="header" href="#marker-traits">Marker traits</a></h3>
<p>Indicate that a type meets certain invariants, so subsequent
users of that type don't need to check at runtime. A common example is to
indicate that a type is safe to serialize into some bytestream.</p>
<h3 id="enums-as-state-machines"><a class="header" href="#enums-as-state-machines">Enums as state machines.</a></h3>
<p>Each enum variant is a state and stores data associated with that state. There
simply is no possibility that the data can get out of sync with the state.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ElectionState {
  RaisingDonations { amount_raised: u32 },
  DoingTVInterviews { interviews_done: u16 },
  Voting { votes_for_me: u64, votes_for_opponent: u64 },
  Elected,
  NotElected,
};
<span class="boring">}
</span></code></pre></pre>
<p>A more heavyweight approach here is to define types for each state, and
allow valid state transitions by taking the previous state by-value and
returning the next state by-value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Seed { water_available: u32 }
struct Growing { water_available: u32, sun_available: u32 }
struct Flowering;
struct Dead;

enum PlantState {
  Seed(Seed),
  Growing(Growing),
  Flowering(Flowering),
  Dead(Dead)
}

impl Seed {
  fn advance(self) -&gt; PlantState {
    if self.water_available &gt; 3 {
      PlantState::Growing(Growing { water_available: self.water_available, sun_available: 0 })
    } else {
      PlantState::Dead(Dead)
    }
  }
}

impl Growing {
  fn advance(self) -&gt; PlantState {
    if self.water_available &gt; 3 &amp;&amp; self.sun_available &gt; 3 {
      PlantState::Flowering(Flowering)
    } else {
      PlantState::Dead(Dead)
    }
  }
}

impl Flowering {
  fn advance(self) -&gt; PlantState {
    PlantState::Dead(Dead)
  }
}

impl Dead {
  fn advance(self) -&gt; PlantState {
    PlantState::Dead(Dead)
  }
}

impl PlantState {
  fn advance(self) -&gt; Self {
    match self {
      Self::Seed(seed) =&gt; seed.advance(),
      Self::Growing(growing) =&gt; growing.advance(),
      Self::Flowering(flowering) =&gt; flowering.advance(),
      Self::Dead(dead) =&gt; dead.advance(),
    }
  }
}

// we should probably find a way to inject some sun and water into this
// state machine or things are not looking rosy
<span class="boring">}
</span></code></pre></pre>
<h2 id="what-should-i-do-instead-of-inheritance"><a class="header" href="#what-should-i-do-instead-of-inheritance">What should I do instead of inheritance?</a></h2>
<p>Use <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition</a>.
Sometimes this results in more boilerplate, but it avoids a raft of complexity.</p>
<p>Specifically, for example:</p>
<ul>
<li>you might include the &quot;superclass&quot; struct as a member of the subclass
struct;</li>
<li>you might use an enum with different variants for the different possible
&quot;subclasses&quot;.</li>
</ul>
<p>Usually the answer is obvious: it's unlikely that your Rust code is structured
in such a way that inheritance would be a good fit anyway.</p>
<blockquote>
<p>I've only missed inheritance when actually <em>implementing</em> languages which
themselves have inheritance. - MG</p>
</blockquote>
<h2 id="i-need-a-list-of-nodes-which-can-refer-to-one-another-how"><a class="header" href="#i-need-a-list-of-nodes-which-can-refer-to-one-another-how">I need a list of nodes which can refer to one another. How?</a></h2>
<p>You can't easily do self-referential data structures in Rust. The usual
workaround is to <a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/">use an
arena</a> and
replace references from one node to another with node IDs.</p>
<p>An arena is typically a <code>Vec</code> (or similar), and the node IDs are a newtype
wrapper around a simple integer index.</p>
<p>Obviously, Rust doesn't check that your node IDs are valid. If you don't have
proper references, what stops you from having stale IDs?</p>
<p>Arenas are often purely additive, which means that you can add entries but not
delete them
(<a href="https://github.com/Manishearth/elsa/blob/master/examples/mutable_arena.rs">example</a>).
If you must have an arena which deletes things, then use generational IDs; see
the <a href="https://docs.rs/generational-arena/">generational-arena</a> crate and this
<a href="https://www.youtube.com/watch?v=aKLntZcp27M">RustConf keynote</a> for more
details.</p>
<p>If arenas still sound like a nasty workaround, consider that you might choose
an arena anyway for other reasons:</p>
<ul>
<li>All of the objects in the arena will be freed at the end of the arena's
lifetime, instead of during their manipulation, which can give very low
latency for some use-cases. <a href="https://docs.rs/bumpalo/3.6.1/bumpalo/">Bumpalo</a>
formalizes this.</li>
<li>The rest of your program might have real Rust references into the arena. You
can give the arena a named lifetime (<code>'arena</code> for example), making the
provenance of those references very clear.</li>
</ul>
<h2 id="im-having-a-miserable-time-making-my-data-structure-should-i-use-unsafe"><a class="header" href="#im-having-a-miserable-time-making-my-data-structure-should-i-use-unsafe">I'm having a miserable time making my data structure. Should I use unsafe?</a></h2>
<p>Low-level data structures are hard in Rust, especially if they're self-
referential. Rust will make visible all sorts of risks of ownership and
shared mutable state which may not be visible in other languages, and
they're hard to solve in low-level data structure code.</p>
<p>Even something as simple as a doubly-linked list is notoriously hard; so much so
that there is a <a href="https://rust-unofficial.github.io/too-many-lists/">book that teaches Rust based solely on linked lists</a>.
As that (wonderful) book makes clear, you are often faced with a choice:</p>
<ul>
<li><a href="https://rust-unofficial.github.io/too-many-lists/fourth.html">Use safe Rust, but shift compile-time checks to runtime</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/fifth.html">Use <code>unsafe</code></a> and
take the same degree of care you'd take in C or C++. And, just like in C or C++,
you'll introduce <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-19029/product_id-48677/Rust-lang-Rust.html">security vulnerabilities in the unsafe code</a>.</li>
</ul>
<p>If you're facing this decision... perhaps there's a third way.</p>
<p>You should almost always be using somebody else's tried-and-tested
data structure.</p>
<p><a href="https://docs.rs/petgraph">petgraph</a> and
<a href="https://docs.rs/slotmap">slotmap</a> are great examples. Use someone else's crate
by default, and resort to writing your own only if you exhaust that option.</p>
<p>C++ makes it hard to pull in third-party dependencies, so it's culturally normal
to write new code. Rust makes it trivial to add dependencies, and so you will
need to do that, even if it feels surprising for a C++ programmer.</p>
<p>This ease of adding dependencies co-evolved with the
difficulty of making data structures. It's simply a part of programming in Rust.
You just can't separate the language and the ecosystem.</p>
<p>You might argue that this dependency on third-party crates is concerning
from a supply-chain security point of view. Your author would agree, but
it's just the way you do things in Rust. Stop creating your own data structures.</p>
<p>Then again:</p>
<blockquote>
<p>it’s equally miserable to implement performant, low-level data structures in
C++; you’ll be specializing on lots of things like is_trivially_movable etc. - MY.</p>
</blockquote>
<h2 id="i-nevertheless-have-to-write-my-own-data-structure-should-i-use-unsafe"><a class="header" href="#i-nevertheless-have-to-write-my-own-data-structure-should-i-use-unsafe">I nevertheless have to write my own data structure. Should I use unsafe?</a></h2>
<p>I'm sorry to hear that.</p>
<p>Some suggestions:</p>
<ul>
<li>Use <code>Rc</code>, weak etc. until you really can't.</li>
<li>Even if you can't use a pre-existing crate for the whole data structure,
perhaps you can use a crate to avoid the <code>unsafe</code> bits (for example
<a href="https://docs.rs/rental/latest/rental/">rental</a>)</li>
<li>Bear in mind that refactoring Rust is generally safer than refactoring
C++ (because the compiler will point out a higher proportion of your
mistakes) so a wise strategy might be to start with a fully-safe, but slow,
version, establish solid tests, and then <a href="https://doc.rust-lang.org/nomicon/">reach for unsafe</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-designing-apis-for-others"><a class="header" href="#questions-about-designing-apis-for-others">Questions about designing APIs for others</a></h1>
<p>See also the excellent <a href="https://rust-lang.github.io/api-guidelines/about.html">Rust API guidelines</a>.
The document you're reading aims to provide extra hints which may be especially
useful to folk coming from C++, but that's the canonical reference.</p>
<h2 id="when-should-my-type-implement-default"><a class="header" href="#when-should-my-type-implement-default">When should my type implement <code>Default</code>?</a></h2>
<p>Whenever you'd provide a default constructor in C++.</p>
<h2 id="when-should-my-type-implement-from-into-and-tryfrom"><a class="header" href="#when-should-my-type-implement-from-into-and-tryfrom">When should my type implement <code>From</code>, <code>Into</code> and <code>TryFrom</code>?</a></h2>
<p>You should think of these as equivalent to implicit conversions in C++. Just
as with C++, if there are <em>multiple</em> ways to convert from your thing to another
thing, don't implement these, but if there's a single obvious conversion, do.</p>
<p>Usually, don't implement <code>Into</code> but instead implement <code>From</code>.</p>
<h2 id="how-should-i-expose-constructors"><a class="header" href="#how-should-i-expose-constructors">How should I expose constructors?</a></h2>
<p>See the previous two answers: where it's simple and obvious, use the standard
traits to make your object behavior predictable.</p>
<p>If you need to go beyond that, remember you've got a couple of extra toys in Rust:</p>
<ul>
<li>A &quot;constructor&quot; could return a <code>Result&lt;Self&gt;</code></li>
<li>Your constructors can have names, e.g. <code>Vec::with_capacity</code>, <code>Box::pin</code></li>
</ul>
<h2 id="when-should-my-type-implement-asref"><a class="header" href="#when-should-my-type-implement-asref">When should my type implement <code>AsRef</code>?</a></h2>
<p>If you have a type which contains another type, provide <code>AsRef</code> especially
so that people can clone the inner type. It's good practice to provide explicit
versions as well (for example, <code>String</code> implements <code>AsRef&lt;str&gt;</code> but also
provides <code>.as_str()</code>.)</p>
<h2 id="when-should-i-implement-copy"><a class="header" href="#when-should-i-implement-copy">When should I implement <code>Copy</code>?</a></h2>
<blockquote>
<p>Anything that is integer-like or reference-like should be <code>Copy</code>; other things
shouldn’t. - MY</p>
</blockquote>
<blockquote>
<p>When it's efficient and when it’s an API contact you're willing to uphold. - AH</p>
</blockquote>
<p>Generally speaking, types which are plain-old-data can be <code>Copy</code>. Anything
more nuanced with any type of state shouldn't be.</p>
<h2 id="should-i-have-arc-or-rc-in-my-api"><a class="header" href="#should-i-have-arc-or-rc-in-my-api">Should I have <code>Arc</code> or <code>Rc</code> in my API?</a></h2>
<blockquote>
<p>It’s a code smell to have reference counts in your API design. You should hide
it. - TM.</p>
</blockquote>
<p>If you must, you will need to decide between <code>Rc</code> and <code>Arc</code> - see the next
answer for some considerations. But, generally, <code>Arc</code> is better practice because
it imposes fewer restrictions on your callers. Also, consider taking a look at the
<a href="https://docs.rs/archery/latest/archery/"><code>Archery</code> crate</a>.</p>
<h2 id="should-my-api-be-thread-safe-what-does-that-mean"><a class="header" href="#should-my-api-be-thread-safe-what-does-that-mean">Should my API be thread-safe? What does that mean?</a></h2>
<p>In C++, a thread-safe API usually means that you can expect your API's
consumers to use objects from multiple threads. This is difficult to make safe
and therefore substantial extra engineering is required to make an API
thread-safe.</p>
<p>In Rust, things differ:</p>
<ul>
<li>it's more normal to do things across multiple threads;</li>
<li>you don't have to worry about your callers making mistakes here because
the compiler won't let them;</li>
<li>you can often rely on <code>Send</code> rather than <code>Sync</code>.</li>
</ul>
<p>You certainly shouldn't be putting a <code>Mutex</code> around all your types. If your
caller attempts to use the type from multiple threads, the compiler will
simply stop them. It is the responsibility of the caller to use things
safely.</p>
<blockquote>
<p>If the library has <code>Arc</code> or <code>Rc</code> in the APIs, it may be making choices about
how you should instantiate stuff, and that’s rude. - AF</p>
</blockquote>
<p>There's a reasonable chance that your API can be used in parallel threads
by virtue of <code>Send</code> and <code>Sync</code> being automatically derived. But - you should
think through the usage model for your API clients and ensure that's true.</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::collections::VecDeque;
use std::sync::Mutex;
use std::thread;

// Imagine this is your library, exposing this interface to library
// consumers...
mod pizza_api {

    use std::thread;
    use std::time::Duration;

    pub struct Pizza {
        // automatically 'Send'
        _anchovies: u32,
        _pepperoni: u32,
    }

    pub fn make_pizza() -&gt; Pizza {
        println!(&quot;cooking...&quot;);
        thread::sleep(Duration::from_millis(10));
        Pizza {
            _anchovies: 0, // yuck
            _pepperoni: 32,
        }
    }

    pub fn eat_pizza(_pizza: Pizza) {
        println!(&quot;yum&quot;)
    }
}

// Absolutely no changes are required to the pizza library to let
// it be usable from a multithreaded context
fn main() {
    let pizza_queue = Mutex::new(RefCell::new(VecDeque::new()));
    thread::scope(|s| {
        s.spawn(|| {
            let mut pizzas_eaten = 0;
            while pizzas_eaten &lt; 100 {
                if let Some(pizza) = pizza_queue.lock().unwrap().borrow_mut().pop_front() {
                    pizza_api::eat_pizza(pizza);
                    pizzas_eaten += 1;
                }
            }
        });
        s.spawn(|| {
            for _ in 0..100 {
                let pizza = pizza_api::make_pizza();
                pizza_queue.lock().unwrap().borrow_mut().push_back(pizza);
            }
        });
    });
}
</code></pre></pre>
<h2 id="what-should-i-derive-to-make-my-code-optimally-usable"><a class="header" href="#what-should-i-derive-to-make-my-code-optimally-usable">What should I <code>Derive</code> to make my code optimally usable?</a></h2>
<p>The <a href="https://rust-lang.github.io/api-guidelines/interoperability.html#types-eagerly-implement-common-traits-c-common-traits">official guidelines say to be eager</a>.</p>
<p>But don't overpromise:</p>
<blockquote>
<p>Equality can suddenly become expensive later - don’t make types comparable
unless you intend people to be able to compare instances of the type.
Allowing people to pattern match on enums is usually better. - MY</p>
</blockquote>
<p>Note that <a href="https://docs.rs/syn/latest/syn/"><code>syn</code> is a rare case</a> in that it
has so many types, and is so extensively depended upon by the rest of the Rust
ecosystem, that it avoids deriving the standard traits unless explicitly
commanded to do so via a cargo feature. This is an unusual pattern and should
not normally be followed.</p>
<h2 id="how-should-i-think-about-api-design-differently-from-c"><a class="header" href="#how-should-i-think-about-api-design-differently-from-c">How should I think about API design, differently from C++?</a></h2>
<blockquote>
<p>Make the most of the fact that everything is immutable by default. Things
which are mutable should stick out. - AF</p>
</blockquote>
<blockquote>
<p>Think about things which should take self and return self. - AF</p>
</blockquote>
<p>Refactoring is less expensive in Rust than C++ due to compiler safeguards, but
<em>rearchitecting</em> is expensive in any language. Think about &quot;one way doors&quot;
and &quot;two way doors&quot; in the design space: can you undo a change later?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-your-whole-codebase"><a class="header" href="#questions-about-your-whole-codebase">Questions about your whole codebase</a></h1>
<h2 id="the-c-observer-pattern-is-hard-in-rust-what-to-do"><a class="header" href="#the-c-observer-pattern-is-hard-in-rust-what-to-do">The C++ observer pattern is hard in Rust. What to do?</a></h2>
<p>The C++ observer pattern usually means that there are broadcasters sending messages to consumers:</p>
<pre class="mermaid">flowchart TB
    broadcaster_a[Broadcaster A]
    broadcaster_b[Broadcaster B]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    consumer_c[Consumer C]
    broadcaster_a --&gt; consumer_a
    broadcaster_b --&gt; consumer_a
    broadcaster_a --&gt; consumer_b
    broadcaster_b --&gt; consumer_b
    broadcaster_a --&gt; consumer_c
    broadcaster_b --&gt; consumer_c
</pre>
<p>The broadcasters maintain lists of consumers, and the consumers act in response to messages (often mutating their own state.)</p>
<p>This doesn't work in Rust, because it requires the broadcasters to hold mutable references to the consumers.</p>
<p>What do you do?</p>
<h3 id="option-1-make-everything-runtime-checked"><a class="header" href="#option-1-make-everything-runtime-checked">Option 1: make everything runtime-checked</a></h3>
<p>Each of your consumers could become an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> or, if you need thread-safety, an <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>.</p>
<p>The <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> allows broadcasters to share ownership of a consumer. The <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a> allows each broadcaster to acquire a mutable reference to a consumer when it needs to send a message.</p>
<p>This example shows how, in Rust, you <a href="https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">may independently choose reference counting <em>or</em> interior mutability</a>. In this case we need both.</p>
<p>Just like typical reference counting in C++, <code>Rc</code> and <code>Arc</code> have the option to provide a weak pointer, so the lifetime of each consumer doesn't need to be extended unnecessarily. As an aside, it would be nice if Rust had an <code>Rc</code>-like type which enforces exactly one owner, and multiple weak ptrs. <code>Rc</code> could be wrapped quite easily to do this.</p>
<p>Reference counting is frowned-upon in C++ because it's expensive. But, in Rust, not so much:</p>
<ul>
<li>Few objects are reference counted; the majority of objects are owned statically.</li>
<li>Even when objects are reference counted, those counts are rarely incremented and decremented because you can (and do) pass around <code>&amp;Rc&lt;RefCell&lt;T&gt;&gt;</code> most of the time. In C++, the &quot;copy by default&quot; mode means it's much more common to increment and decrement reference counts.</li>
</ul>
<p>In fact, the compile-time guarantees might cause you to do <em>less</em> reference counting than C++:</p>
<blockquote>
<p>In Servo there is a reference count but far fewer objects are reference counted than in the rest of Firefox, because you don’t need to be paranoid - MG</p>
</blockquote>
<p>However: Rust does <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">not prevent reference cycles</a>, although they're only possible if you're using <em>both</em> reference counting and interior mutability.</p>
<h3 id="option-2-drive-the-objects-from-the-code-not-the-other-way-round"><a class="header" href="#option-2-drive-the-objects-from-the-code-not-the-other-way-round">Option 2: drive the objects from the code, not the other way round</a></h3>
<p>In C++, it's common to have all behavior within classes. Those classes <em>are</em> the total behavior of the system, and so they must interact with one another. The observer pattern is common.</p>
<pre class="mermaid">flowchart TB
    broadcaster_a[Broadcaster A]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    broadcaster_a -- observer --&gt; consumer_a
    broadcaster_a -- observer --&gt; consumer_b
</pre>
<p>In Rust, it's more common to have some <em>external</em> function which drives overall behavior.</p>
<pre class="mermaid">flowchart TB
    main(Main)
    broadcaster_a[Broadcaster A]
    consumer_a[Consumer A]
    consumer_b[Consumer B]
    main --1--&gt; broadcaster_a
    broadcaster_a --2--&gt; main
    main --3--&gt; consumer_a
    main --4--&gt; consumer_b
</pre>
<p>With this sort of design, it's relatively straightforward to take some output from one object and pass it into another object, with no need for the objects to interact at all.</p>
<p>In the most extreme case, this becomes the <a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity-Component-System architecture</a> used in game design.</p>
<blockquote>
<p>Game developers seem to have completely solved this problem - we can learn from them. - MY</p>
</blockquote>
<h3 id="option-3-use-channels"><a class="header" href="#option-3-use-channels">Option 3: use channels</a></h3>
<p>The observer pattern is a way to decouple large, single-threaded C++ codebases. But if you're trying to decouple a codebase in Rust, perhaps you should assume multi-threading by default? Rust has built-in <a href="https://doc.rust-lang.org/std/sync/mpsc/">channels</a>, and the <a href="https://docs.rs/crossbeam/0.8.0/crossbeam/">crossbeam</a> crate provides multi-producer, multi-consumer channels.</p>
<blockquote>
<p>I'm a Rustacean, we assume massively parallel unless told otherwise :) - MG</p>
</blockquote>
<h2 id="thats-all-very-well-but-i-have-an-existing-c-object-broadcasting-events-how-exactly-should-i-observe-it"><a class="header" href="#thats-all-very-well-but-i-have-an-existing-c-object-broadcasting-events-how-exactly-should-i-observe-it">That's all very well, but I have an existing C++ object broadcasting events. How exactly should I observe it?</a></h2>
<p>If your Rust object is a consumer of events from some pre-existing C++ producer, all the above options remain possible.</p>
<ul>
<li>You can make your object reference counted and have C++ own such a reference (potentially a weak reference)</li>
<li>C++ can deliver the message into a general message bucket. An external function reads messages from that bucket and invokes the Rust object that should handle it. This means the reference counting doesn't need to extend to the Rust objects outside that boundary layer.</li>
<li>You can have a shim object which converts the C++ callback into some message and injects it into a channel-based world.</li>
</ul>
<h2 id="some-of-my-c-objects-have-shared-mutable-state-how-can-i-make-them-safe-in-rust"><a class="header" href="#some-of-my-c-objects-have-shared-mutable-state-how-can-i-make-them-safe-in-rust">Some of my C++ objects have shared mutable state. How can I make them safe in Rust?</a></h2>
<p>You're going to have to do something with <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>: either <code>RefCell&lt;T&gt;</code> or its multithreaded equivalent, <code>RwLock&lt;T&gt;</code>.</p>
<p>You have three decisions to make:</p>
<ol>
<li>Will only Rust code access <em>this particular instance</em> of this object, or might C++ access it too?</li>
<li>If both C++ and Rust may access the object, how do you avoid conflicts?</li>
<li>How should Rust code react if the object is not available, because something else is using it?</li>
</ol>
<p>If only Rust code can use this particular instance of shared state, then simply wrap it in <code>RefCell&lt;T&gt;</code> (single-threaded) or <code>RwLock&lt;T&gt;</code> (multi-threaded). Build a wrapper type such that callers aren't able to access the object directly, but instead only via the lock type.</p>
<p>If C++ also needs to access this particular instance of the shared state, it's more complex. There are presumably some invariants regarding use of this data in C++ - otherwise it would crash all the time. Perhaps the data can be used only from one thread, or perhaps it can only be used with a given mutex held. Your goal is to translate those invariants into an idiomatic Rust API that can be checked (ideally) at compile-time, and (failing that) at runtime.</p>
<p>For example, imagine:</p>
<pre><code class="language-cpp">class SharedMutableGoat {
public:
    void eat_grass(); // mutates tummy state
};

std::mutex lock;
SharedMutableGoat* billy; // only access when owning lock
</code></pre>
<p>Your idiomatic Rust wrapper might be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ffi {
</span><span class="boring">  #[allow(non_camel_case_types)]
</span><span class="boring">  pub struct lock_guard;
</span><span class="boring">  pub fn claim_lock() -&gt; lock_guard { lock_guard{} }
</span><span class="boring">  pub fn eat_grass() {}
</span><span class="boring">  pub fn release_lock(lock: &amp;mut lock_guard) {}
</span><span class="boring">}
</span>struct SharedMutableGoatLock {
    lock: ffi::lock_guard, // owns a std::lock_guard&lt;std::mutex&gt; somehow
};

// Claims the lock, returns a new SharedMutableGoatLock
fn lock_shared_mutable_goat() -&gt; SharedMutableGoatLock {
    SharedMutableGoatLock { lock: ffi::claim_lock() }
}

impl SharedMutableGoatLock {
    fn eat_grass(&amp;mut self) {
        ffi::eat_grass(); // Acts on the global goat
    }
}

impl Drop for SharedMutableGoatLock {
    fn drop(&amp;mut self) {
        ffi::release_lock(&amp;mut self.lock);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Obviously, lots of permutations are possible, but the goal is to ensure that it's simply compile-time impossible to act on the global state unless appropriate preconditions are met.</p>
<p>The final decision is how to react if the object is not available. This decision can apply with C++ mutexes or with Rust locks (for example <code>RwLock&lt;T&gt;</code>). As in C++, the two major options are:</p>
<ul>
<li>Block until the object becomes available.</li>
<li>Try to lock, and if the object is not available, do something else.</li>
</ul>
<p>There can be a third option if you're using async Rust. If the data isn't available, you may be able to return to your event loop using an async version of the lock (<a href="https://docs.rs/tokio/1.5.0/tokio/sync/struct.RwLock.html#method.read">Tokio example</a>, <a href="https://docs.rs/async-std/1.9.0/async_std/sync/struct.RwLock.html">async_std example</a>).</p>
<h2 id="how-do-i-do-a-singleton"><a class="header" href="#how-do-i-do-a-singleton">How do I do a singleton?</a></h2>
<p>Use <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html">OnceCell</a>.</p>
<h2 id="whats-the-best-way-to-retrofit-rusts-parallelism-benefits-to-an-existing-codebase"><a class="header" href="#whats-the-best-way-to-retrofit-rusts-parallelism-benefits-to-an-existing-codebase">What's the best way to retrofit Rust's parallelism benefits to an existing codebase?</a></h2>
<p>When parallelizing an existing codebase, first check that all existing types are correctly <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>. Generally, though, you should try to avoid implementing these yourself - instead use pre-existing wrapper types which enforce the correct contract (for example, <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>).</p>
<p>After that:</p>
<blockquote>
<p>If you can solve your problem by throwing Rayon at it, do. It’s magic - MG</p>
</blockquote>
<blockquote>
<p>If your task is CPU-bound, Rayon solves this handily. - MY</p>
</blockquote>
<p><a href="https://docs.rs/rayon/1.5.0/rayon/">Rayon</a> offers parallel constructs - for example parallel iterators - which can readily be retrofitted to an existing codebase. It also allows you to create and join tasks. Using Rayon can help <em>simplify</em> your code and eliminate lots of manual scheduling logic.</p>
<p>If your tasks are IO-bound, then you may need to look into async Rust, but that's hard to pull into an existing codebase.</p>
<h2 id="whats-the-best-way-to-architect-a-new-codebase-for-parallelism"><a class="header" href="#whats-the-best-way-to-architect-a-new-codebase-for-parallelism">What's the best way to architect a new codebase for parallelism?</a></h2>
<p>In brief, like in other languages, you have a choice of architectures:</p>
<ul>
<li>Message-passing, using event loops which listen on a channel, receive <code>Send</code> data and pass it on.</li>
<li>More traditional multithreading using <code>Sync</code> data structures such as mutexes (and perhaps Rayon).</li>
</ul>
<blockquote>
<p>There's probably a bias towards message-passing, and that's probably well-informed by its extensibility. - MG</p>
</blockquote>
<h2 id="i-need-a-list-of-nodes-which-can-refer-to-one-another-how-1"><a class="header" href="#i-need-a-list-of-nodes-which-can-refer-to-one-another-how-1">I need a list of nodes which can refer to one another. How?</a></h2>
<p>You can't easily do self-referential data structures in Rust. The usual workaround is to <a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/">use an arena</a> and replace references from one node to another with node IDs.</p>
<p>An arena is typically a <code>Vec</code> (or similar), and the node IDs are a newtype wrapper around a simple integer index.</p>
<p>Obviously, Rust doesn't check that your node IDs are valid. If you don't have proper references, what stops you from having stale IDs?</p>
<p>Arenas are often purely additive, which means that you can add entries but not delete them (<a href="https://github.com/Manishearth/elsa/blob/master/examples/mutable_arena.rs">example</a>). If you must have an arena which deletes things, then use generational IDs; see the <a href="https://docs.rs/generational-arena/">generational-arena</a> crate and this <a href="https://www.youtube.com/watch?v=aKLntZcp27M">RustConf keynote</a> for more details.</p>
<p>If arenas still sound like a nasty workaround, consider that you might choose an arena anyway for other reasons:</p>
<ul>
<li>All of the objects in the arena will be freed at the end of the arena's lifetime, instead of during their manipulation, which can give very low latency for some use-cases. <a href="https://docs.rs/bumpalo/3.6.1/bumpalo/">Bumpalo</a> formalizes this.</li>
<li>The rest of your program might have real Rust references into the arena. You can give the arena a named lifetime (<code>'arena</code> for example), making the provenance of those references very clear.</li>
</ul>
<h2 id="should-i-have-a-few-big-crates-or-lots-of-small-ones"><a class="header" href="#should-i-have-a-few-big-crates-or-lots-of-small-ones">Should I have a few big crates or lots of small ones?</a></h2>
<p>In the past, it was recommended to have small crates to get optimal build time.
Incremental builds generally make this unnecessary now. You should arrange your
crates optimally for your semantic needs.</p>
<h2 id="what-crates-should-everyone-know-about"><a class="header" href="#what-crates-should-everyone-know-about">What crates should everyone know about?</a></h2>
<table><thead><tr><th align="left">Crate</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><a href="https://docs.rs/rayon/">rayon</a></td><td align="left">parallelizing</td></tr>
<tr><td align="left"><a href="https://docs.rs/serde/">serde</a></td><td align="left">serializing and deserializing</td></tr>
<tr><td align="left"><a href="https://docs.rs/crossbeam/">crossbeam</a></td><td align="left">all sorts of parallelism tools</td></tr>
<tr><td align="left"><a href="https://docs.rs/itertools/">itertools</a></td><td align="left">makes it slightly more pleasant to work with iterators. (For instance, if you want to join an iterator of strings, you can just go ahead and do that, without needing to collect the strings into a <code>Vec</code> first)</td></tr>
<tr><td align="left"><a href="https://docs.rs/petgraph/">petgraph</a></td><td align="left">graph data structures</td></tr>
<tr><td align="left"><a href="https://docs.rs/slotmap/">slotmap</a></td><td align="left">arena-like key-value map</td></tr>
<tr><td align="left"><a href="https://docs.rs/nom/">nom</a></td><td align="left">parsing</td></tr>
<tr><td align="left"><a href="https://docs.rs/clap/">clap</a></td><td align="left">command-line parsing</td></tr>
<tr><td align="left"><a href="https://docs.rs/regex/">regex</a></td><td align="left">err, regular expressions</td></tr>
<tr><td align="left"><a href="https://docs.rs/ring/">ring</a></td><td align="left">the leading crypto library</td></tr>
<tr><td align="left"><a href="https://docs.rs/nalgebra/">nalgebra</a></td><td align="left">linear algebra</td></tr>
<tr><td align="left"><a href="https://docs.rs/once_cell/">once_cell</a></td><td align="left">complex static data</td></tr>
</tbody></table>
<h2 id="how-should-i-call-c-functions-from-rust-and-vice-versa"><a class="header" href="#how-should-i-call-c-functions-from-rust-and-vice-versa">How should I call C++ functions from Rust and vice versa?</a></h2>
<p>Use <a href="https://cxx.rs">cxx</a>.</p>
<p>Oh, you want a justification? In that case, here's the history
which brought us to this point.</p>
<p>From the beginning, Rust supported calling C functions using <a href="https://doc.rust-lang.org/std/keyword.extern.html"><code>extern &quot;C&quot;</code></a>,
<a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a>
and <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[no_mangle]</code></a>.
Such callable C functions had to be declared manually in Rust:</p>
<pre class="mermaid">sequenceDiagram
   Rust--&gt;&gt;extern: unsafe Rust function call
   extern--&gt;&gt;C: call from Rust to C
   participant extern as Rust unsafe extern &quot;C&quot; fn
   participant C as Existing C function
</pre>
<p><a href="https://rust-lang.github.io/rust-bindgen/"><code>bindgen</code></a> was invented
to generate these declarations automatically from existing C/C++ header
files. It has grown to understand an astonishingly wide variety of C++
constructs, but its generated bindings are still <code>unsafe</code> functions
with lots of pointers involved.</p>
<pre class="mermaid">sequenceDiagram
   Rust--&gt;&gt;extern: unsafe Rust function call
   extern--&gt;&gt;C: call from Rust to C++
   participant extern as Bindgen generated bindings
   participant C as Existing C++ function
</pre>
<p>Interacting with <code>bindgen</code>-generated bindings requires unsafe Rust;
you will likely have to manually craft idiomatic safe Rust wrappers.
This is time-consuming and error-prone.</p>
<p><a href="https://cxx.rs">cxx</a> automates a lot of that process. Unlike <code>bindgen</code>
it doesn't learn about functions from existing C++ headers. Instead,
you specify cross-language interfaces in a Rust-like interface definition
language (IDL) within your Rust file. cxx generates both C++ and Rust code
from that IDL, marshaling data behind the scenes on both sides such that
you can use standard language features in your code. For example, you'll
find idiomatic Rust wrappers for <a href="https://docs.rs/cxx/1.0.50/cxx/struct.CxxString.html"><code>std::string</code></a>
and <a href="https://docs.rs/cxx/1.0.50/cxx/struct.UniquePtr.html"><code>std::unique_ptr</code></a>
and idiomatic C++ wrappers for <a href="https://cxx.rs/binding/slice.html">a Rust slice</a>.</p>
<pre class="mermaid">sequenceDiagram
   Rust--&gt;&gt;rsbindings: safe idiomatic Rust function call
   rsbindings--&gt;&gt;cxxbindings: hidden C ABI call using marshaled data
   cxxbindings--&gt;&gt;cpp: call to standard idiomatic C++
   participant rsbindings as cxx-generated Rust code
   participant cxxbindings as cxx-generated C++ code
   participant cpp as C++ function using STL types
</pre>
<blockquote>
<p>In the bindgen case even more work goes into wrapping idiomatic C++ signatures into something bindgen compatible: unique ptrs to raw ptrs, Drop impls on the Rust side, translating string types ... etc. The typical real-world binding we've converted from bindgen to cxx in my codebase has been -500 lines (mostly unsafe code) +300 lines (mostly safe code; IDL included). - DT</p>
</blockquote>
<p>The greatest benefit is that cxx sufficiently understands C++ STL
object ownership norms that the generated bindings can be used from
safe Rust code.</p>
<p>At present, there is no established solution which combines the idiomatic, safe
interoperability offered by <code>cxx</code> with the automatic generation offered by
<code>bindgen</code>. It's not clear whether this is even <em>possible</em> but <a href="https://github.com/google/autocxx">several</a>
<a href="https://github.com/google/mosaic">projects</a> are aiming in this direction.</p>
<h2 id="im-getting-a-lot-of-binary-bloat"><a class="header" href="#im-getting-a-lot-of-binary-bloat">I'm getting a lot of binary bloat.</a></h2>
<p>In Rust you have a free choice between <code>impl Trait</code> and <code>dyn Trait</code>. See
<a href="signatures.html#When_should_I_take_or_return_dyn_Trait">this answer</a>, too. <code>impl Trait</code> tends
to be the default, and results in large binaries as much code can be duplicated.
If you have this problem, consider using <code>dyn Trait</code>. Other options include
the 'thin template pattern' (an example is <code>serde_json</code> where the code to read
from <a href="https://github.com/serde-rs/json/blob/master/src/read.rs#L172">a string and a slice</a>
would be duplicated entirely, but instead one delegates to the other and
requests slightly different behavior.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-about-your-development-processes"><a class="header" href="#questions-about-your-development-processes">Questions about your development processes</a></h1>
<h2 id="how-should-i-use-tools-differently-from-c"><a class="header" href="#how-should-i-use-tools-differently-from-c">How should I use tools differently from C++?</a></h2>
<ul>
<li><em>Use <code>rustfmt</code> automatically everywhere.</em> While in C++ there are many
different coding styles, the Rust community is in agreement (at least,
they're in agreement that it's a good idea to be in agreement). That
is codified in <code>rustfmt</code>. Use it, automatically, on every submission.</li>
<li><em>Use <code>clippy</code> somewhere</em>. Its lints are useful.</li>
<li><em>Use IDEs more liberally</em>. Even staunch vim-adherents (your author!)
prefer to use an IDE with Rust, because it's simply invaluable to show
type annotations. Type information is typically invisible in the language
so in Rust you're more reliant on tooling assistance.</li>
<li><em>Deny unsafe code</em> by default. (<code>#![forbid(unsafe_code)]</code>).</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="third_party/mermaid/mermaid.min.js"></script>
                <script type="text/javascript" src="third_party/mermaid/mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
